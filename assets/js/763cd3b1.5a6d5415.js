"use strict";(self.webpackChunkdogsounds_til=self.webpackChunkdogsounds_til||[]).push([[17949],{68339:(n,e,r)=>{r.d(e,{Zo:()=>l,kt:()=>m});var t=r(39953);function o(n,e,r){return e in n?Object.defineProperty(n,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[e]=r,n}function c(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function a(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?c(Object(r),!0).forEach((function(e){o(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function i(n,e){if(null==n)return{};var r,t,o=function(n,e){if(null==n)return{};var r,t,o={},c=Object.keys(n);for(t=0;t<c.length;t++)r=c[t],e.indexOf(r)>=0||(o[r]=n[r]);return o}(n,e);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(n);for(t=0;t<c.length;t++)r=c[t],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(n,r)&&(o[r]=n[r])}return o}var s=t.createContext({}),u=function(n){var e=t.useContext(s),r=e;return n&&(r="function"==typeof n?n(e):a(a({},e),n)),r},l=function(n){var e=u(n.components);return t.createElement(s.Provider,{value:e},n.children)},p="mdxType",d={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},f=t.forwardRef((function(n,e){var r=n.components,o=n.mdxType,c=n.originalType,s=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),p=u(r),f=o,m=p["".concat(s,".").concat(f)]||p[f]||d[f]||c;return r?t.createElement(m,a(a({ref:e},l),{},{components:r})):t.createElement(m,a({ref:e},l))}));function m(n,e){var r=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var c=r.length,a=new Array(c);a[0]=f;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=n,i[p]="string"==typeof n?n:o,a[1]=i;for(var u=2;u<c;u++)a[u]=r[u];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},60168:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var t=r(855),o=(r(39953),r(68339));const c={id:"09-\ud654"},a="23.05.09.",i={unversionedId:"\uc1a1\uc740\uc218/23.05/09-\ud654",id:"\uc1a1\uc740\uc218/23.05/09-\ud654",title:"23.05.09.",description:"- \ucef4\uacf5\uc2e4",source:"@site/members/\uc1a1\uc740\uc218/23.05/09 (\ud654).md",sourceDirName:"\uc1a1\uc740\uc218/23.05",slug:"/\uc1a1\uc740\uc218/23.05/09-\ud654",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.05/09-\ud654",draft:!1,editUrl:"https://github.com/Self-Driven-Development/TIL/tree/main/members/\uc1a1\uc740\uc218/23.05/09 (\ud654).md",tags:[],version:"current",frontMatter:{id:"09-\ud654"},sidebar:"all",previous:{title:"23.05.08.",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.05/08-\uc6d4"},next:{title:"23.05.11.",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.05/11-\ubaa9"}},s={},u=[{value:"\ucef4\uacf5\uc2e4",id:"\ucef4\uacf5\uc2e4",level:2},{value:"tetris project Second week",id:"tetris-project-second-week",level:3}],l={toc:u},p="wrapper";function d(n){let{components:e,...r}=n;return(0,o.kt)(p,(0,t.Z)({},l,r,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"230509"},"23.05.09."),(0,o.kt)("h1",{id:"today-i-learned"},"Today I learned"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\ucef4\uacf5\uc2e4")),(0,o.kt)("h2",{id:"\ucef4\uacf5\uc2e4"},"\ucef4\uacf5\uc2e4"),(0,o.kt)("h3",{id:"tetris-project-second-week"},"tetris project Second week"),(0,o.kt)("p",null,"\ud568\uc218 4\uac1c \uad6c\ud604\ud558\uae30.. segmantation fault\uac00 \ub5a0\uc11c \uc5b4\ub514\uc11c \uc5d0\ub7ec\uac00 \ub5b4\ub294\uc9c0 \ubaa8\ub974\uaca0\ub2e4.",(0,o.kt)("br",{parentName:"p"}),"\n","\ub9de\uac8c \ud55c\uac74\uc9c0\ub3c4 \ubaa8\ub974\uaca0\ub2e4.",(0,o.kt)("br",{parentName:"p"}),"\n","\ub0b4\uc77c \uc644\uc131\uc2dc\ucf1c\uc57c\uc9c0...",(0,o.kt)("br",{parentName:"p"}),"\n","ps. \uc65c \ub0b4\uaebc\ub294 tab\uac04\uaca9\uc774 4\uce78\uc774\uc57c?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C"},'void createRankList() {\n    // \ubaa9\uc801: Input\ud30c\uc77c\uc778 "rank.txt"\uc5d0\uc11c \ub7ad\ud0b9 \uc815\ubcf4\ub97c \uc77d\uc5b4\ub4e4\uc784, \uc77d\uc5b4\ub4e4\uc778 \uc815\ubcf4\ub85c \ub7ad\ud0b9 \ubaa9\ub85d \uc0dd\uc131\n    // 1. "rank.txt"\uc5f4\uae30\n    // 2. \ud30c\uc77c\uc5d0\uc11c \ub7ad\ud0b9\uc815\ubcf4 \uc77d\uc5b4\uc624\uae30\n    // 3. LinkedList\ub85c \uc800\uc7a5\n    // 4. \ud30c\uc77c \ub2eb\uae30\n    FILE* fp;\n    int i;\n    Node* curr = head;\n    //1. \ud30c\uc77c \uc5f4\uae30\n    fp = fopen("rnak.txt", "r");\n\n    // 2. \uc815\ubcf4\uc77d\uc5b4\uc624\uae30\n    /* int fscanf(FILE* stream, const char* format, ...);\n    stream:\ub370\uc774\ud130\ub97c \uc77d\uc5b4\uc62c \uc2a4\ud2b8\ub9bc\uc758 FILE \uac1d\uccb4\ub97c \uac00\ub9ac\ud0a4\ub294 \ud30c\uc77c\ud3ec\uc778\ud130\n    format: \ud615\uc2dd\uc9c0\uc815\uc790 \ub4f1\ub4f1\n    \ubcc0\uc218\uc758 \uc8fc\uc18c: \ud3ec\uc778\ud130\n    return: \uc131\uacf5\ud560 \uacbd\uc6b0, fscanf \ud568\uc218\ub294 \uc77d\uc5b4\ub4e4\uc778 \ub370\uc774\ud130\uc758 \uc218\ub97c \ub9ac\ud134, \uc2e4\ud328\ud558\uba74 EOF\ub9ac\ud134 */\n    // EOF(End Of File): \uc2e4\uc81c\ub85c \uc774 \uac12\uc740 -1\uc744 \ub098\ud0c0\ub0c4, EOF\uac00 \ub098\ud0c0\ub0a0\ub54c\uae4c\uc9c0 \uc785\ub825\ubc1b\uc544\uc624\ub294 if\ubb38\n    while (1) {\n        //\ube48\ud30c\uc77c\uc774\uba74 break\n        if (fscanf(fp, "%d", &score_number) != EOF) {\n            //score_number\ub9cc\ud07c \uc2e4\ud589\n            for (i = 0; i < score_number; i++) {\n                Node* node = (Node*)malloc(sizeof(Node));\n                fscanf(fp, "%s%d", node->name, &(node->score));\n                node->next = NULL;\n                //empty check\n                if (head == NULL) {\n                    head = node;\n                    curr = head;\n                }\n                else {\n                    curr->next = node;\n                    curr = node;\n                }\n            }\n        }\n        else {\n            break;\n        }\n    }\n    // 4. \ud30c\uc77c\ub2eb\uae30\n    fclose(fp);\n    return;\n}\n\nvoid rank() {\n    //\ubaa9\uc801: rank \uba54\ub274\ub97c \ucd9c\ub825\ud558\uace0 \uc810\uc218 \uc21c\uc73c\ub85c X\ubd80\ud130~Y\uae4c\uc9c0 \ucd9c\ub825\ud568\n    //1. \ubb38\uc790\uc5f4 \ucd08\uae30\ud654\n    int X = 1, Y = score_number, ch, i, j;\n    clear();\n\n    //2. printw()\ub85c 3\uac1c\uc758 \uba54\ub274\ucd9c\ub825\n    printw("1. list ranks from X to Y\\n ");\n    printw("2. list ranks by a specific name\\n");\n    printw("3. delete a specific rank\\n");\n\n    //3. wgetch()\ub97c \uc0ac\uc6a9\ud558\uc5ec \ubcc0\uc218 ch\uc5d0 \uc785\ub825\ubc1b\uc740 \uba54\ub274\ubc88\ud638 \uc800\uc7a5\n    ch = wgetch(stdscr);\n\n\n    //4. \uac01 \uba54\ub274\uc5d0 \ub530\ub77c \uc785\ub825\ubc1b\uc744 \uac12\uc744 \ubcc0\uc218\uc5d0 \uc800\uc7a5\n    //4-1. \uba54\ub2741: X, Y\ub97c \uc785\ub825\ubc1b\uace0 \uc801\uc808\ud55c input\uc778\uc9c0 \ud655\uc778 \ud6c4(X<=Y), X\uc640 Y\uc0ac\uc774\uc758 rank \ucd9c\ub825\n    if (ch == \'1\') {\n        printw("X: ");\n        scanw("%d", &X);\n        printw("Y: ");\n        scanw("%d", &Y);\n        if (X > Y) {\n            printw("search failure: no rank in the list");\n            return;\n        }\n        count = 1;\n        Node* curr = head;\n        printw("        name       |    score\\n");\n        printw("--------------------------------------\\n");\n        for (i = count; i <= Y; i++) {\n            if (X <= i && i <= Y) {\n                printw(" %-18s| %-12d\\n", curr->name, curr->score);\n            }\n            curr = curr->next;\n            if (curr == NULL) break;\n        }\n    }\n\n    //4-2. \uba54\ub2742: \ubb38\uc790\uc5f4\uc744 \ubc1b\uc544 \uc800\uc7a5\ub41c \uc774\ub984\uacfc \ube44\uad50\ud558\uace0 \uc774\ub984\uc5d0 \ud574\ub2f9\ud558\ub294 \ub9ac\uc2a4\ud2b8\ub97c \ucd9c\ub825\n    else if (ch == \'2\') {\n        char str[NAMELEN + 1];\n        int check = 0;\n\n\n    }\n\n    //4-3. \uba54\ub2743: rank\ubc88\ud638\ub97c \uc785\ub825\ubc1b\uc544 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc0ad\uc81c\n    else if (ch == \'3\') {\n        int num;\n\n    }\n    getch();\n\n}\n\nvoid writeRankFile() {\n    // \ubaa9\uc801: \ucd94\uac00\ub41c \ub7ad\ud0b9 \uc815\ubcf4\uac00 \uc788\uc73c\uba74 \uc0c8\ub85c\uc6b4 \uc815\ubcf4\ub97c "rank.txt"\uc5d0 \uc4f0\uace0 \uc5c6\uc73c\uba74 \uc885\ub8cc\n    int sn, i;\n    Node* curr = head;\n    //1. "rank.txt" \uc5f0\ub2e4\n    FILE* fp = fopen("rank.txt", "r");\n    fscanf(fp, "%d", &sn);\n    if (sn == score_number) return;\n    //2. \ub7ad\ud0b9 \uc815\ubcf4\ub4e4\uc758 \uc218\ub97c "rank.txt"\uc5d0 \uae30\ub85d\n    fp = fopen("rank.txt", "w");\n    fprintf(fp, "%d\\n", score_number);\n    //3. \ud0d0\uc0c9\ud560 \ub178\ub4dc\uac00 \ub354 \uc788\ub294\uc9c0 \uccb4\ud06c\ud558\uace0 \uc788\uc73c\uba74 \ub2e4\uc74c \ub178\ub4dc\ub85c \uc774\ub3d9, \uc5c6\uc73c\uba74 \uc885\ub8cc\n    while (curr) {\n        fprintf(fp, "%s %d\\n", curr->name, curr->score);\n        curr = curr->next;\n    }\n    fclose(fp);\n}\n\nvoid newRank(int score) {\n    // \ubaa9\uc801: GameOver\uc2dc \ud638\ucd9c\ub418\uc5b4 \uc0ac\uc6a9\uc790 \uc774\ub984\uc744 \uc785\ub825\ubc1b\uace0 score\uc640 \ud568\uaed8 \ub9ac\uc2a4\ud2b8\uc758 \uc801\uc808\ud55c \uc704\uce58\uc5d0 \uc800\uc7a5\n    char str[NAMELEN + 1];\n    int i, j;\n    Node* node = (Node*)malloc(sizeof(Node));\n    Node* curr = head;\n    clear();\n    //1. \uc0ac\uc6a9\uc790 \uc774\ub984\uc744 \uc785\ub825\ubc1b\uc74c\n    move(0, 0);\n    printw("your name: ");\n    getstr(str);\n    strcpy(node->name, str);\n    //2. \uc0c8\ub85c\uc6b4 \ub178\ub4dc\ub97c \uc0dd\uc131\ud574 \uc774\ub984\uacfc \uc810\uc218\ub97c \uc800\uc7a5, score_number\uac00\n    score_number++;\n    node->score = score;\n    node->next = NULL;\n    if (head==NULL) {\n        head = node;\n    }\n    else if(curr->score<score){\n        node->next = curr;\n        curr = node;\n        head = curr;\n    }\n    else {\n        while (curr->next != NULL) {\n            if (curr->next->score > score) {\n                curr = curr->next;\n            }\n            else {\n                break;\n            }\n        }\n        node->next = curr->next;\n        curr->next = node;\n    }\n    writeRankFile();\n}\n')))}d.isMDXComponent=!0}}]);