"use strict";(self.webpackChunkdogsounds_til=self.webpackChunkdogsounds_til||[]).push([[3145],{68339:(e,n,t)=>{t.d(n,{Zo:()=>h,kt:()=>m});var r=t(39953);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=r.createContext({}),p=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},h=function(e){var n=p(e.components);return r.createElement(d.Provider,{value:n},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,d=e.parentName,h=a(e,["components","mdxType","originalType","parentName"]),s=p(t),f=i,m=s["".concat(d,".").concat(f)]||s[f]||c[f]||l;return t?r.createElement(m,o(o({ref:n},h),{},{components:t})):r.createElement(m,o({ref:n},h))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=f;var a={};for(var d in n)hasOwnProperty.call(n,d)&&(a[d]=n[d]);a.originalType=e,a[s]="string"==typeof e?e:i,o[1]=a;for(var p=2;p<l;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},90558:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>p});var r=t(855),i=(t(39953),t(68339));const l={title:"05 (\uc6d4)"},o=void 0,a={unversionedId:"\uc1a1\uc740\uc218/23.06/05",id:"\uc1a1\uc740\uc218/23.06/05",title:"05 (\uc6d4)",description:"\uc624\ub298 \ud55c\uc904 \ud53c\ub4dc\ubc31",source:"@site/members/\uc1a1\uc740\uc218/23.06/05.md",sourceDirName:"\uc1a1\uc740\uc218/23.06",slug:"/\uc1a1\uc740\uc218/23.06/05",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.06/05",draft:!1,editUrl:"https://github.com/Self-Driven-Development/TIL/tree/main/\uc1a1\uc740\uc218/23.06/05.md",tags:[],version:"current",frontMatter:{title:"05 (\uc6d4)"},sidebar:"all",previous:{title:"04 (\uc77c)",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.06/ 04"},next:{title:"06 (\ud654)",permalink:"/TIL/members/\uc1a1\uc740\uc218/23.06/06"}},d={},p=[{value:"\uc624\ub298 \ud55c\uc904 \ud53c\ub4dc\ubc31",id:"\uc624\ub298-\ud55c\uc904-\ud53c\ub4dc\ubc31",level:2},{value:"\uae30\ubcf8\uac1c\ub150",id:"\uae30\ubcf8\uac1c\ub150",level:2},{value:"Traversal",id:"traversal",level:2},{value:"Threaded Binary Tree",id:"threaded-binary-tree",level:2},{value:"Heap",id:"heap",level:2},{value:"Binary Search Tree",id:"binary-search-tree",level:2},{value:"Selection Trees",id:"selection-trees",level:2}],h={toc:p},s="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(s,(0,r.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"\uc624\ub298-\ud55c\uc904-\ud53c\ub4dc\ubc31"},"\uc624\ub298 \ud55c\uc904 \ud53c\ub4dc\ubc31"),(0,i.kt)("p",null,"\uacf5\ubd80 \ud558\ub824\uace0 \ud559\uad50\uc5d0 \uac14\uc9c0\ub9cc \uc815\uc791 \uacf5\ubd80\ub97c \ubcc4\ub85c \ubabb\ud55c \uc624\ub298. \uc5ec\uc790\uce5c\uad6c\uc640 \uce74\uacf5\ud558\uba70 \ube61\uacf5\ud55c\ub2e4\ub294 \uac74 \uc5b4\ubd88\uc131\uc124."),(0,i.kt)("h1",{id:"\uc790\ub8cc\uad6c\uc870"},"\uc790\ub8cc\uad6c\uc870"),(0,i.kt)("p",null,"\uc8fc\ub85c \ud2b8\ub9ac\uc5d0 \ub300\ud574 \uacf5\ubd80\ud588\ub2e4."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"\uae30\ubcf8\uac1c\ub150"},"\uae30\ubcf8\uac1c\ub150"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"degree : \uc790\uc2dd\uc758 \uac2f\uc218"),(0,i.kt)("li",{parentName:"ul"},"level : depth\ub791 \ube44\uc2b7\ud55c \uac1c\ub150, root\ub178\ub4dc\uc758 level\uc740 1\uc774\uace0 maximum level==height"),(0,i.kt)("li",{parentName:"ul"},"complete binary tree : \ub9c8\uc9c0\ub9c9 level-1\uae4c\uc9c0\uc758 level\uc740 \uc804\ubd80 \ucc44\uc6cc\uc838 \uc788\uace0, \ub9c8\uc9c0\ub9c9 level\uc740 \uc67c\ucabd\ubd80\ud130 \ucc44\uc6cc\uc838\ub098\uac00\ub294 binary tree")),(0,i.kt)("h2",{id:"traversal"},"Traversal"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},'typedef struct _node{\n  int data;\n  struct _node* left;//struct \ube7c\uba39\uc9c0 \uc54a\uae30\n  struct _node* right;\n}node;\n\nvoid inorder(node* root){\n  if(root){//null\uc774\ub77c\uba74 \uc811\uadfc \ubabb\ud558\ub3c4\ub85d \uc870\uac74\ubb38\n    inorder(root->left);\n    printf("%d\\n",root->data);\n    inorder(root->right);\n  }\n}\n\nnode* makenode(node* root,int num){\n  int n=7;//n is f 2^k-1 for k is positive integer\n  if(num<=n){\n    node *ptr1=(node*)malloc(sizeof(node));\n    ptr1->left=NULL;\n    ptr1->right=NULL;\n    node *ptr2=(node*)malloc(sizeof(node));\n    ptr2->left=NULL;\n    ptr2->right=NULL;\n    root->data=num;\n    root->left=makenode(ptr1,2*num);\n    root->right=makenode(ptr2,2*num+1);\n    return root;\n  }\n  else {//\uc774\uc0c1\uc758 \uac12\uc774\uba74 \ub354\ubbf8 root\ub97c \ubc18\ud658\ud558\ub294\uac8c \uc544\ub2c8\ub77c NULL\uc744 \ubc18\ud658\n    return NULL;\n  }\n}\n\nint main(void){\n  node *ptr=(node*)malloc(sizeof(node));\n  ptr->data=1;\n  ptr->left=NULL;\n  ptr->right=NULL;\n  makenode(ptr,1);\n  inorder(ptr);\n  return 0;\n}\n')),(0,i.kt)("p",null,"\uc7ac\uadc0\uac00 \uc544\ub2cc \ubc18\ubcf5\ubb38\uc744 \uc0ac\uc6a9\ud55c\ub2e4\uba74?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},'void iter_inorder(tree_pointer ptr) { \n  int top = -1;\n  tree_pointer stack[MAX_STACK_SIZE];\n  for( ; ; ) {\n    for( ; ptr; ptr = ptr->left_child)\n      stack[++top] = ptr;\n    if(top < 0) break;\n    ptr = stack[top--];\n    printf("%c ", ptr->data);\n    ptr = ptr->right_child;\n  }\n}\n')),(0,i.kt)("p",null,"\ub450 \ub178\ub4dc\uac00 \uac19\uc740 \uc9c0, \ub2e4\ub978 \uc9c0 \ube44\uad50\ud560 \ub550 NULL\uc77c \ub54c\ub3c4 \ube44\uad50\ud574\uc57c \ud55c\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},"//node\uac00 \uac19\uc740\uc9c0 \ube44\uad50\nint equal(tree_pointer first, tree_pointer second) {\n    //\ub458\ub2e4 NULL\uc774\uba74 TRUE, \uc544\ub2c8\uba74 \ub458\ub2e4 NULL\uc774 \uc544\ub2c8\uba74\uc11c \ubaa8\ub4e0 \uac12\uc774 \uac19\uc544\uc57c \ud55c\ub2e4\n  return((!first && !second) || (first && second &&\n         (first->data == second->data) &&\n         equal(first->left_child, second->left_child) &&\n         equal(first->right_child, second->right_child))\n}\n")),(0,i.kt)("h2",{id:"threaded-binary-tree"},"Threaded Binary Tree"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},"struct threaded_tree {\n  short int left_thread;\n    struct threaded_tree *left_child; \n    char data;\n    struct threaded_tree *right_child; \n    short int right_thread;\n};\n")),(0,i.kt)("p",null,"tree\uad6c\uc870\uc758 leaf\ub97c \uc0b4\ud3b4\ubcf4\uba74 \uc790\uc2dd\uc774 \uc5c6\uae30 \ub54c\ubb38\uc5d0 \ud574\ub2f9 \ud3ec\uc778\ud130\uac00 NULL\uac12\uc744 \uac19\ub294\ub370, perfect binary tree\uc5d0\uc11c leaf\ub178\ub4dc\uc758 \uac2f\uc218\uac00 leaf\ub178\ub4dc\uac00 \uc544\ub2cc \uac2f\uc218\ubcf4\ub2e4 \ub9ce\uae30 \ub54c\ubb38\uc5d0 \uc774\ub294 \uba54\ubaa8\ub9ac \ub0ad\ube44\uac00 \uc2ec\ud558\ub2e4.",(0,i.kt)("br",{parentName:"p"}),"\n","\uc774\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574 \ub178\ub4dc\uc758 \uad6c\uc870\uccb4\uc5d0\uc11c thread\ub97c \ucd94\uac00\ud55c\ub2e4.",(0,i.kt)("br",{parentName:"p"}),"\n","thread\ub97c \uc2e4\ucc98\ub7fc \uc0dd\uac01\ud574 \ubaa8\ub4e0 \ub178\ub4dc\ub97c \ud558\ub098\ub85c \uc774\uc5b4\uc900\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},"threaded_pointer insucc(threaded_pointer tree) {\n    /* find the inorder successor of a tree in a threaded binary tree */ \n    threaded_pointer temp;\n    //right_thread\uac00 true -> leaf -> right_child\uac00 successor(\ud6c4\uc704)\n    //right_thread\uac00 false -> !leaf -> right_child\uc5d0\uc11c left_child\uac00 leaf\uc77c\ub54c\uae4c\uc9c0 \ub0b4\ub824\uac00\uae30\n    temp = tree->right_child;\n    if(!tree->right_thread)//null\uc774\ub77c\uba74\n        while(!temp->left_thread)\n          temp = temp->left_child;\n    return temp;//\ucc38\uc774\ub77c\uba74 leaf\uc784\uc73c\ub85c \uadf8\ub300\ub85c \ubc18\ud658\n}\n")),(0,i.kt)("h2",{id:"heap"},"Heap"),(0,i.kt)("p",null,"\ub370\uc774\ud130\ub97c \uc800\uc7a5\ud558\uae30 \uc704\ud55c \ubc29\ubc95. \ucc3e\uac70\ub098 \uc0bd\uc785\ud558\uac70\ub098\uc758 \uc2dc\uac04\ubcf5\uc7a1\ub3c4\uac00 O(log n)\uc774\ub77c \uc720\uc6a9\ud558\uac8c \uc0ac\uc6a9\ud55c\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},'#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define MAX_ELEMENTS 200\n#define HEAP_FULL(n) (n == MAX_ELEMENTS-1)\n#define HEAP_EMPTY(n) (!n)\n\ntypedef struct {\n  int key;\n} element;\nelement heap[MAX_ELEMENTS];\nint n = 0;\n\nvoid insert_max_heap(element item, int *n);\nelement delete_max_heap(int *n);\n\nint main() {\n\n  int i, rn;\n  element item;\n\n  srand(time(NULL));\n \n  printf("INSERTING: ");\n  for(i=0; i<10; i++) {\n    rn = rand() % 100 + 1;\n    printf("%3d ", rn);\n    item.key = rn;\n    insert_max_heap(item, &n);\n  }\n  printf("\\n\\n");\n\n  printf("DELETING:  ");\n  for(i=0; i<10; i++) {\n    item = delete_max_heap(&n);\n    printf("%3d ", item.key);\n  }\n  printf("\\n");\n}\n\nvoid insert_max_heap(element item, int *n) {\n  /* insert item into a max heap of current size *n */\n  int i;\n  if(HEAP_FULL(*n)) {\n    fprintf(stderr, "The heap is full.\\n");\n    exit(1);\n  }\n      i = ++(*n);\n    /* \ud56d\uc0c1 \ub9c8\uc9c0\ub9c9\ubc30\uc5f4+1\uc5d0\uc11c \uc2dc\uc791, \ubd80\ubaa8\ub178\ub4dc\uc640 \ube44\uad50\ud558\uc5ec \ub354 \ud06c\uba74 \uad50\uccb4 \n        root\ub178\ub4dc\uc5d0 \ub3c4\ub2ec\ud558\uba74 \uc885\ub8cc */\n  while((i != 1) && (item.key > heap[i/2].key)) {\n    heap[i] = heap[i/2];\n    i /= 2;\n  }\n  heap[i] = item;\n}\n\nelement delete_max_heap(int *n) {\n  /* delete element with the highest key from the heap */\n  int parent, child;\n  element item, temp;\n  if(HEAP_EMPTY(*n)) {\n    fprintf(stderr, "The heap is empty");\n    exit(1);\n  }\n    //root\ub178\ub4dc\uc758 \uac12\uc744 pop, \ub9c8\uc9c0\ub9c9\ub178\ub4dc\ub97c root\ub178\ub4dc\ub85c \uac00\uc838\uc640 \ube44\uad50\ud574\ubcf4\uba70 \ub9ac\ube4c\ub529\n  /* save value of the element with the largest key */\n  item = heap[1];\n  /* use the last element in the heap to adjust heap */\n  temp = heap[(*n)--];\n  parent = 1;\n  child = 2;\n  while(child <= *n) {\n    /* find the larger child of the current parent */\n    if((child < *n) && (heap[child].key < heap[child+1].key)) child++;\n    if(temp.key >= heap[child].key) break;\n    /* move to the next lower level */\n    heap[parent] = heap[child];\n    parent = child;\n    child *= 2;\n  }\n  heap[parent] = temp;\n  return item;\n}\n')),(0,i.kt)("h2",{id:"binary-search-tree"},"Binary Search Tree"),(0,i.kt)("p",null,"\ubc14\uc774\ub108\ub9ac \ud2b8\ub9ac\uc5d0 \uac11\uc774 \ub4e4\uc5b4\uac00 \uc788\ub2e4  \uc67c\ucabd\uc790\uc2dd\uc740 \ubd80\ubaa8\ub178\ub4dc\ubcf4\ub2e4 \uc791\uc740 \uac12, \uc624\ub978\ucabd\uc790\uc2dd\uc740 \ubd80\ubaa8\ub178\ub4dc\ubcf4\ub2e4 \ud070 \uac12\uc744 \uac16\ub294\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"},'#include <stdio.h>\n#include <stdlib.h>\n\n#define TRUE 1\n#define FALSE 0\n#define MAX_STACK_SIZE 100\n#define LEFT 0\n#define RIGHT 1\n\ntypedef struct {\n    int key;\n} element;\n\nstruct node {\n    element data;\n    struct node *leftChild;\n    struct node *rightChild;\n};\ntypedef struct node* treePointer;\n\nvoid inorder(treePointer ptr) {\n    if(ptr) {\n        inorder(ptr->leftChild);\n        printf("%d ", ptr->data.key);\n        inorder(ptr->rightChild);\n    }\n}\n\ntreePointer modifiedSearch(treePointer node, int k) {\n    treePointer parent = NULL;\n    while(node) {\n        if(k == node->data.key) return NULL;\n        parent = node;\n        if(k < node->data.key) node = node->leftChild;\n        else node = node->rightChild;\n    }\n    return parent;\n}\n\nvoid insertNode(treePointer *node, int k) {\n    // if the key is already in the tree, do nothing; otherwise add a new node with key k\n    treePointer ptr, temp = modifiedSearch(*node, k);\n    if(temp || !(*node)) {\n        // k is not in the tree\n        ptr = (treePointer)malloc(sizeof(*ptr));\n        ptr->data.key = k;\n        ptr->leftChild = ptr->rightChild = NULL;\n        if(*node) {\n            if(k < temp->data.key) temp->leftChild = ptr;\n            else temp->rightChild = ptr;\n        }\n        else *node = ptr;\n        printf("node with key %d inserted.\\n", k);\n    } else {\n        printf("key %d is already in the tree.\\n", k);\n    }\n}\n\nvoid deleteNode(treePointer *root, int k) {\n    treePointer node = *root;\n    treePointer parent = NULL;\n    int which_child;\n    \n    // search for the node\n    while(node) {\n        if(k == node->data.key) break;\n        parent = node;\n        if(k < node->data.key) {\n            node = node->leftChild;\n            which_child = LEFT;\n        }\n        else {\n            node = node->rightChild;\n            which_child = RIGHT;\n        }\n    }\n\n    // case 1: if the node does not exist, we are done.\n    if(node == NULL) return;\n\n    // case 2: if the node is a leaf node, just set the corresponding child field of its parent to NULL and free the node.\n    if(node->leftChild == NULL && node->rightChild == NULL) {\n        if(parent == NULL) {\n            // this is a root node\n            *root = NULL;\n        }\n        else {\n            if(which_child == LEFT) parent->leftChild = NULL;\n            else parent->rightChild = NULL;\n        }\n        free(node);\n    }\n    // case 3: if the node is a non-leaf node with a single child\n    else if(node->leftChild == NULL || node->rightChild == NULL) {\n      if(which_child==LEFT){//\uc5b4\ub290 \ubc29\ud5a5\uc73c\ub85c \uc654\ub294\uc9c0 \ud655\uc778\n                //\uc5b4\ub290 \ub178\ub4dc\uac00 \ube44\uc5b4\uc788\ub294\uc9c0 \ud655\uc778\n        if(node->leftChild==NULL) parent->leftChild=node->rightChild;\n        else parent->leftChild=node->leftChild;\n      }\n      else{\n        if(node->leftChild==NULL) parent->rightChild=node->rightChild;\n        else parent->rightChild=node->leftChild;\n      }\n    }\n\n    // case 4: if the deleted node is a nonleaf node with two children\n    // \ud070\ucabd\uc758 \uac00\uc7a5 \uc791\uc740 \uc218 or \uc791\uc740\ucabd\uc758 \uac00\uc7a5 \ud070 \uc218, \uc791\uc740\ucabd\uc758 \uac00\uc7a5 \ud070 \uc218 \ucc44\ud0dd\n    else {\n      treePointer temp = node;\n      treePointer tempParent = node;\n      temp=temp->leftChild;\n      if(!temp->rightChild){\n        tempParent=temp;\n        temp=temp->rightChild;\n      }\n      node->data=temp->data;\n      if(tempParent==node){//NULL\ub85c \ucd08\uae30\ud654\ud558\ub294 \uac83\uc774 \uc544\ub2c8\ub77c \uc774\uc5b4\uc8fc\uae30\n        tempParent->leftChild=node->leftChild;\n      }\n      else{\n        tempParent->rightChild=node->rightChild;\n      }\n    }\n}\n\nint main() {\n   \n    treePointer root = NULL;\n    insertNode(&root, 8);\n    insertNode(&root, 6);\n    insertNode(&root, 9);\n    insertNode(&root, 7);\n    insertNode(&root, 10);\n    insertNode(&root, 7);\n    inorder(root); printf("\\n");\n    deleteNode(&root, 9);\n    inorder(root); printf("\\n");\n}\n')),(0,i.kt)("p",null,"\uc911\uc704\uc21c\ud68c\ubc29\uc2dd\uc73c\ub85c \ub370\uc774\ud130\uac00 \uc800\uc7a5\ub41c\ub2e4. Insert\uacfc\uc815\uc5d0\uc11c\ub294 case\ubd84\ub958\ub97c \ud560 \ud544\uc694 \uc5c6\uc9c0\ub9cc Delete\uacfc\uc815\uc5d0\uc11c\ub294 case\ub97c \ubd84\ub958\ud55c\ub2e4. "),(0,i.kt)("h2",{id:"selection-trees"},"Selection Trees"),(0,i.kt)("p",null,"\ud1a0\ub108\uba3c\ud2b8 \uacbd\uae30\ucc98\ub7fc \ud574\uc11d\ud55c\ub2e4. n\uac1c\uc758 \ud300\uc774 \uc788\uace0, n-1\ubc88\uc758 \uacbd\uae30\uac00 \uc788\ub2e4.",(0,i.kt)("br",{parentName:"p"}),"\n","\uac01 \ud300\uc740 \uac00\uc911\uce58 \uac12\uc744 \uac00\uc9c0\uace0 \uc788\ub2e4.",(0,i.kt)("br",{parentName:"p"}),"\n","\uc2b9\uc790\ud2b8\ub9ac(Winner Tree), \ud328\uc790\ud2b8\ub9ac(Looser Tree) \ub450 \uc885\ub958\uac00 \uc788\ub2e4.   "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\uc2b9\uc790\ud2b8\ub9ac : \ub450 \ud300\uc758 \uac00\uc911\uce58\ub97c \ube44\uad50\ud574 \ub354 \uc791\uc740 \uac12\uc744 \uc9c4\ucd9c\uc2dc\ud0a8\ub2e4. \uacc4\uc18d \ubc18\ubcf5\ud574 \uac00\uc7a5 \uc791\uc740 \uac12\uc774 \uc6b0\uc2b9\uc744 \ud55c\ub2e4.\n\uc2dc\uac04\ubcf5\uc7a1\ub3c4\ub294 n\uac1c\uc758 \ud300\uc774 log n\ub9cc\ud07c\uc758\uc2dc\uac04\uc774 \uac78\ub9ac\ub294 \uc815\ub82c\ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\ubbc0\ub85c O(n log n)\uc774\ub2e4"),(0,i.kt)("li",{parentName:"ul"},"\ud328\uc790\ud2b8\ub9ac : \uc2b9\uc790\ud2b8\ub9ac\uc640 \ub611\uac19\uc740 \ubc29\uc2dd\uc778\ub370, \ud45c\uae30\ub294 \ud328\uc790 \ud300\uc744 \uae30\ub85d\ud55c\ub2e4. \uc774\ud6c4 \ud1a0\ub108\uba3c\ud2b8\uc5d0\uc11c\ub3c4 \ud328\uc790 \ud300\uc744 \uae30\ub85d\ud55c\ub2e4. \uadf8\ub9ac\uace0 \ucd5c\uc885\uc2b9\uc790\ub294 \uc784\uc758\uc758 \ucd5c\uc0c1\uc704 \ub178\ub4dc\ub97c \uc0c8\ub85c\ub9cc\ub4e4\uc5b4 \uc800\uc7a5\ud55c\ub2e4.\n\uc774\ub807\uac8c \ud558\uba74 \uac01 \ud300\uc744 \ubc30\uc5f4\ub85c \uc0dd\uac01\ud588\uc744 \ub54c, \ud328\uc790\ud2b8\ub9ac\ub294 \uc2b9\uc790\ud2b8\ub9ac\uc5d0\uc11c \ud558\ub294 \ud615\uc81c\ub07c\ub9ac\uc758 \uacc4\uc0b0\uc744 \ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\ubbc0\ub85c \ubbf8\uc138\ud55c \uc2dc\uac04\uc774\ub4dd\uc774 \ubc1c\uc0dd\ud55c\ub2e4.")))}c.isMDXComponent=!0}}]);