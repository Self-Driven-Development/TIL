# 23.07.27(목)
## 1. [react-query를 이용한 낙관적 업데이트](https://github.com/TanStack/query/blob/main/examples/react/optimistic-updates-typescript/src/pages/index.tsx)

```js
const client = new QueryClient()

type Todos = {
  items: readonly {
    id: string
    text: string
  }[]
  ts: number
}

async function fetchTodos(): Promise<Todos> {
  const res = await axios.get('/api/data')
  return res.data
}

function useTodos() {
  return useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
}

function Example() {
  const queryClient = useQueryClient()
  const [text, setText] = React.useState('')
  const { isFetching, ...queryInfo } = useTodos()

  const addTodoMutation = useMutation({
    mutationFn: (newTodo) => axios.post('/api/data', { text: newTodo }),
    // When mutate is called:
    onMutate: async (newTodo: string) => {
      setText('')
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({ queryKey: ['todos'] })

      // Snapshot the previous value
      const previousTodos = queryClient.getQueryData<Todos>(['todos'])

      // Optimistically update to the new value
      if (previousTodos) {
        queryClient.setQueryData<Todos>(['todos'], {
          ...previousTodos,
          items: [
            ...previousTodos.items,
            { id: Math.random().toString(), text: newTodo },
          ],
        })
      }

      return { previousTodos }
    },
    // If the mutation fails,
    // use the context returned from onMutate to roll back
    onError: (err, variables, context) => {
      if (context?.previousTodos) {
        queryClient.setQueryData<Todos>(['todos'], context.previousTodos)
      }
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <p>
        In this example, new items can be created using a mutation. The new item
        will be optimistically added to the list in hopes that the server
        accepts the item. If it does, the list is refetched with the true items
        from the list. Every now and then, the mutation may fail though. When
        that happens, the previous list of items is restored and the list is
        again refetched from the server.
      </p>
      <form
        onSubmit={(e) => {
          e.preventDefault()
          addTodoMutation.mutate(text)
        }}
      >
        <input
          type="text"
          onChange={(event) => setText(event.target.value)}
          value={text}
        />
        <button disabled={addTodoMutation.isLoading}>Create</button>
      </form>
      <br />
      {queryInfo.isSuccess && (
        <>
          <div>
            {/* The type of queryInfo.data will be narrowed because we check for isSuccess first */}
            Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}
          </div>
          <ul>
            {queryInfo.data.items.map((todo) => (
              <li key={todo.id}>{todo.text}</li>
            ))}
          </ul>
          {isFetching && <div>Updating in background...</div>}
        </>
      )}
      {queryInfo.isLoading && 'Loading'}
      {queryInfo.error instanceof Error && queryInfo.error.message}
    </div>
  )
}

export default function App() {
  return (
    <QueryClientProvider client={client}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

### 낙관적 업데이트의 핵심 코드
```js
onMutate: async (newTodo: string) => {
  setText('')
  await queryClient.cancelQueries({ queryKey: ['todos'] })
  const previousTodos = queryClient.getQueryData<Todos>(['todos'])
  if (previousTodos) {
    queryClient.setQueryData<Todos>(['todos'], {
      ...previousTodos,
      items: [
        ...previousTodos.items,
        { id: Math.random().toString(), text: newTodo },
      ],
    })
  }

  return { previousTodos }
},
```
- `setText('')` : input 초기화
- `await queryClient.cancelQueries({ queryKey: ['todos'] })` : 쿼리가 실행되는 동안 새로운 쿼리가 실행되지 않도록 쿼리를 취소
-  `const previousTodos = queryClient.getQueryData<Todos>(['todos'])` : 이전 쿼리 데이터를 가져옴
- `queryClient.setQueryData<Todos>(['todos'], { ...previousTodos, items: [ ...previousTodos.items, { id: Math.random().toString(), text: newTodo }, ], })` : 이전 쿼리 데이터를 가져와서 새로운 데이터를 추가한 후 쿼리 데이터를 업데이트 (즉, 낙관적 업데이트)
- `return { previousTodos }` : 이전 쿼리 데이터를 반환

### 낙관적 업데이트 이후의 코드
```js
onError: (err, variables, context) => {
  if (context?.previousTodos) {
    queryClient.setQueryData<Todos>(['todos'], context.previousTodos)
  }
},
// Always refetch after error or success:
onSettled: () => {
  queryClient.invalidateQueries({ queryKey: ['todos'] })
},
```

- `onError: (err, variables, context) => { if (context?.previousTodos) { queryClient.setQueryData<Todos>(['todos'], context.previousTodos) } }` : 에러가 발생하면 이전 쿼리 데이터를 가져와서 쿼리 데이터를 업데이트
-  `onSettled: () => { queryClient.invalidateQueries({ queryKey: ['todos'] }) }` : 에러가 발생하든 성공하든 쿼리를 다시 실행
   -  `queryClient.invalidateQueries({ queryKey: ['todos'] })` : 캐싱을 초기화, 즉 쿼리를 다시 실행