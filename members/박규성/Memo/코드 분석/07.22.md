# 07.22

## 1. `useCallback` [(useTextArea)](https://github.dev/depromeet/Ding-dong-fe)
```js
'use client';
import { ChangeEvent, ChangeEventHandler, useCallback, useState } from 'react';

export type UseTextAreaProps = {
  initValue?: string;
  onChange: ChangeEventHandler;
  maxLength?: number;
};

export const useTextArea = ({ initValue = '', onChange, maxLength }: UseTextAreaProps) => {
  const [value, setValue] = useState(initValue);

  const onChangeHandler = useCallback(
    (e: ChangeEvent<HTMLTextAreaElement>) => {
      e.target.value = e.target.value.slice(0, maxLength);
      onChange(e);
      setValue(e.target.value);
    },
    [maxLength, onChange],
  );

  return { value, onChangeHandler };
};
```
- 사용법
```js
const { onChangeHandler, value: contents } = useTextArea({
  onChange: register('contents').onChange,
});
```
```js
<TextArea.Content
  {...register('contents')}
  onChange={onChangeHandler}
  value={contents}
/>
```
1. `onChangeHandler`함수를 선언한다. 이 함수는 텍스트 영역의 값이 변경될 때 호출되는 함수이다. 이 함수는 텍스트 영역의 입력값을 `maxLength`에 지정된 길이로 제한하고, `onChange` 함수를 호출한 후, 텍스트 영역의 상태를 업데이트한다.. 이 함수는 useCallback hook을 사용하여 메모이제이션되어, maxLength나 onChange 값이 변경되지 않는 한 같은 참조를 유지한다.
   - 이 떄, `useCallback`을 사용함으로써 이 `onChangeHandler`를 props로 전달했을 때, 자식 컴포넌트의 불필요한 리렌더링을 방지할 수 있다.

## 2. `useCallback` [(KeywordContentImage)](https://github.dev/depromeet/Ding-dong-fe)
```js
'use client';

import { useCallback } from 'react';
import { useFormContext } from 'react-hook-form';

import { CancelCircleIcon } from '~/components/Icon';
import { IdCardCreationFormModel } from '~/types/idCard';
type KeywordContentImageProps = {
  index: number;
};

export const KeywordContentImage = ({ index }: KeywordContentImageProps) => {
  const { watch, setValue } = useFormContext<IdCardCreationFormModel>();
  const { keywords } = watch();
  const imageUrl = keywords[index].imageUrl;

  const onCancelClick = useCallback(() => {
    setValue(`keywords.${index}.imageUrl`, '');
  }, [index, setValue]);

  return imageUrl ? (
    <div className="relative mx-auto my-0 w-fit">
      {/* eslint-disable-next-line @next/next/no-img-element */}
      <img
        src={imageUrl}
        className="max-h-[192px] max-w-[308px] object-contain"
        alt="image preview"
      />
      <div className="absolute right-[12px] top-[12px] flex h-[16px] w-[16px]  items-center justify-center rounded-full bg-grey-800">
        <CancelCircleIcon className="fill-grey-800" onClick={onCancelClick} />
      </div>
    </div>
  ) : null;
};

```
- onClick함수로 넘겨지는 `onCancelClick`함수를 메모이제이션했다. 이 함수는 클릭했을 때 `setValue`를 사용하여 해당 인덱스의 `imageUrl`필드를 빈 문자열로 설정한다. 

## 3. [Compound Component(합성 컴포넌트)](https://github.dev/depromeet/Ding-dong-fe)
```js
// src/components/TopNavigation/index.tsx
import { TopNavigationBackButton } from './TopNavigationBackButton';
import { TopNavigationLeft } from './TopNavigationLeft';
import { TopNavigationProgressBar } from './TopNavigationProgressBar';
import { TopNavigationRight } from './TopNavigationRight';
import { TopNavigationTitle } from './TopNavigationTitle';
import { TopNavigationWrapper } from './TopNavigationWrapper';

export const TopNavigation = Object.assign(TopNavigationWrapper, {
  Left: TopNavigationLeft,
  Title: TopNavigationTitle,
  Right: TopNavigationRight,
  BackButton: TopNavigationBackButton,
  ProgressBar: TopNavigationProgressBar,
});
```
- TopNavigation의 왼쪽 버튼, 오른쪽 버튼, 제목 등을 각각 import하여 TopNavigation으로 묶어서 export한다.
- 이렇게 하면, TopNavigation을 import할 때, TopNavigation.Left, TopNavigation.Right 등으로 사용할 수 있다.

```js
// src/components/TopNavigation/TopNavigationLeft.tsx
import { PropsWithChildren } from 'react';

import { tw } from '~/utils/tailwind.util';

type TopNavigationLeftProps = {
  className?: string;
};

export const TopNavigationLeft = ({
  children,
  className,
}: PropsWithChildren<TopNavigationLeftProps>) => {
  return (
    <div className={tw('flex min-w-[33%] max-w-full justify-start', className)}>{children}</div>
  );
};

```
- TopNavigationLeft 컴포넌트는 자식 컴포넌트를 받아서, 자식 컴포넌트를 왼쪽에 정렬하여 보여준다.

```js
// src/components/TopNavigation/TopNavigationBackButton.tsx
'use client';
import { useRouter } from 'next/navigation';
import { twMerge } from 'tailwind-merge';

import { ArrowLeftIcon, CancelBoldIcon, ChevronLeftIcon } from '~/components/Icon';

const BackButton = {
  chevron: ChevronLeftIcon,
  cancel: CancelBoldIcon,
  arrow: ArrowLeftIcon,
};

type BackButtonType = keyof typeof BackButton;

type TopNavigationBackButtonProps = {
  /**
   * 좌측 아이콘 타입
   * @default 'chevron'
   */
  backButtonType?: BackButtonType;
  /**
   * 좌측 아이콘을 클릭할 때 동작하는 함수, 값을 넣지 않으면 기본적으로 router.back이 실행됩니다.
   */
  onClickBackButton?: VoidFunction;
  backLink?: string;
  direction?: 'left' | 'right';
};

export const TopNavigationBackButton = ({
  backButtonType = 'chevron',
  backLink,
  onClickBackButton,
  direction = 'left',
}: TopNavigationBackButtonProps) => {
  const router = useRouter();

  const handleClickBackButton = () => {
    if (onClickBackButton) {
      onClickBackButton();
      return;
    }
    if (backLink) {
      router.push(backLink);
      return;
    }
    router.back();
  };

  const BackButtonComponent = BackButton[backButtonType];
  return (
    <button
      className={twMerge(direction === 'left' ? 'justify-start' : 'justify-end')}
      onClick={handleClickBackButton}
    >
      <BackButtonComponent />
    </button>
  );
};

```
- TopNavigationBackButton 컴포넌트는 backButtonType에 따라서 다른 아이콘을 보여준다. 또한, backLink가 주어지면 해당 링크로 이동하고, onClickBackButton이 주어지면 해당 함수를 실행한다.


```js
// src/components/TopNavigation/TopNavigationWrapper.tsx
import { PropsWithChildren } from 'react';

type TopNavigationWrapperProps = {
  /**
   * border-bottom 컬러 값이 주어지면 표시합니다. ex) color-primary
   */
  bottomBorderColor?: string;
  bgColor?: string;
};
export const TopNavigationWrapper = ({
  bottomBorderColor,
  bgColor = 'bg-white',
  children,
}: PropsWithChildren<TopNavigationWrapperProps>) => {
  const borderBottomStyle = bottomBorderColor ? `border-b-${bottomBorderColor} border-b-[1px]` : '';
  return (
    <nav
      className={`fixed left-0 right-0 top-0 z-top2 mx-auto flex h-t-nav w-full max-w-content items-center justify-between px-layout-sm ${borderBottomStyle} ${bgColor}`}
    >
      {children}
    </nav>
  );
};

```
- TopNavigationWrapper 컴포넌트는 자식 컴포넌트를 받아서, 자식 컴포넌트를 가운데 정렬하여 보여준다.

### 사용 방법
```js
<TopNavigation>
  <TopNavigation.Left>
    <div className="py-2">
      <h1 className="text-h1">알림</h1>
    </div>
  </TopNavigation.Left>
</TopNavigation>
```
- `TopNavigation`으로 가장 크게 감싼다. 
- `TopNavigation.Left`로 왼쪽에 보여줄 컴포넌트를 감싼다.



- 이런 식으로 `index.tsx`에서 모아서 export하는 방식이 있고, 또한 한 파일에서 모든 컴포넌트를 만들어 export하는 방식이 있다. 

## 4. [Compound Component(합성 컴포넌트) 2 (주혁님 코드)](https://github.com/gloddy-dev/gloddy-client)
```js
'use client';
import clsx from 'clsx';
import { type PropsWithChildren, createContext, useContext, useEffect, useState } from 'react';

import type { StrictPropsWithChildren } from '@/types';

const TabsContext = createContext<{
  activeTab: string | number;
  setActiveTab: (value: string | number) => void;
} | null>(null);

interface TabsProps {
  defaultActiveTab: string | number;
}

export default function Tabs({ defaultActiveTab, children }: StrictPropsWithChildren<TabsProps>) {
  const [activeTab, setActiveTab] = useState(defaultActiveTab);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>{children}</TabsContext.Provider>
  );
}

function List({ children }: StrictPropsWithChildren) {
  return <div className="flex h-50 border-b border-white3">{children}</div>;
}

interface TabProps {
  value: string;
  text: string;
  queryString?: string;
}

function Tab({ value, text, queryString }: TabProps) {
  const { activeTab, setActiveTab } = useContext(TabsContext)!;

  const isActive = activeTab === value;

  useEffect(() => {
    if (isActive) {
      const url = new URL(window.location.href);
      url.searchParams.set('tab', queryString ?? value);
      window.history.replaceState(null, '', url.toString());
    }
  }, [isActive, queryString, value]);

  return (
    <div
      className={clsx(
        'flex flex-1 cursor-pointer items-center justify-center',
        isActive && 'border-b-4 border-blue3'
      )}
      onClick={() => setActiveTab(value)}
    >
      {text}
    </div>
  );
}

function Panel({ value, children }: PropsWithChildren<Pick<TabProps, 'value'>>) {
  const { activeTab } = useContext(TabsContext)!;

  return <div className={activeTab === value ? 'block' : 'hidden'}>{children}</div>;
}

Tabs.List = List;
Tabs.Tab = Tab;
Tabs.Panel = Panel;
```
- 크게 `Tabs`, `List`, `Tab`, `Panel`로 구성되어 있다. `Tabs` 컴포넌트가 본체이고, `List`, `Tab`, `Panel`은 `Tabs`의 자식 컴포넌트이다. `Tabs`컴포넌트는 현재 활성화 중인 탭의 상태값 Context인 `TabsContext.Provider`로 감싸고 있다. 그리고 `List`는 `Tab`을 둘러싸는 박스이다. `Tab`은 탭의 이름과 활성화 여부를 나타내는 `isActive`값을 갖고 있다. `Panel`은 `Tab`의 `value`값과 `Tabs`의 `activeTab`값이 같으면 보여지는 컴포넌트이다.

### 사용 방법

```js
<Tabs defaultActiveTab={currentTab}>
  <Tabs.List>
    <Tabs.Tab value="detail" text="상세정보" />
    <Tabs.Tab value="board" text="게시판" />
  </Tabs.List>
  <Tabs.Panel value="detail">
    <div className="p-20">{detailNode}</div>
    {!isLeader && (
      <BottomFixedButton
        text="지원하기"
        onClick={() => router.push(`/grouping/${groupingId}/apply`)}
      />
    )}
  </Tabs.Panel>
  <Tabs.Panel value="board">
    <div className="p-20">{boardNode}</div>
    <BottomFixedButton
      text="글쓰기"
      onClick={() => router.push(`/grouping/${groupingId}/write`)}
    />
  </Tabs.Panel>
</Tabs>
```
- `Tabs`로 넓게 둘러싼다. `Tabs`의 `Context.Proivder`가 현재 활성화 중인 `Tab`의 상태를 관리한다. 
- `Tabs.List`로 `Tab`을 둘러싼다. `Tabs.Tab`은 `value`값과 `text`값을 받는다. `value`값은 `Tabs.Panel`의 `value`값과 비교하여 같으면 활성화된다. 
- `Tabs.Panel`은 `value`값과 `Tabs`의 `activeTab`값이 같으면 보여지는 컴포넌트이다.