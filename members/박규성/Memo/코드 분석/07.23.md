# 23.07.23()

## 1. [useMutation - 낙관적 업더ㅔ이트](https://github.dev/depromeet/Ding-dong-fe)

```js
export const commentQueryKey = {
  comments: (idCardId: number) => ['comments', idCardId],
  commentReplies: (idCardId: number, commentId: number) => ['replies', idCardId, commentId],
  commentCount: (idCardId: number) => ['commentCount', idCardId],
};

export const deleteComment = ({ idCardId, commentId }: CommentDeleteRequest) =>
  privateApi.delete<CommentDeleteResponse>(`id-cards/${idCardId}/comments/${commentId}`);



// useDeleteComment 커스텀 훅. 댓글 삭제 기능을 처리하는데 사용
export const useDeleteComment = (idCardId: number) => {
  // QueryClient 인스턴스를 가져옴. 이 인스턴스를 사용해 쿼리 데이터를 읽고 쓸 수 있음
  const queryClient = useQueryClient();

  // 에러 메시지를 표시하는 훅
  const { errorToast } = useToastMessageStore();

  // useMutation 훅. 댓글 삭제 API를 호출하고 응답을 처리하는 함수를 생성
  return useMutation({
    // API 호출을 수행하는 함수. CommentDeleteRequest 형식의 데이터를 받아 deleteComment 함수에 전달
    mutationFn: (commentInfo: CommentDeleteRequest) => deleteComment(commentInfo),

    // 댓글 삭제 API 호출 전에 실행하는 함수
    onMutate: async (commentInfo: CommentDeleteRequest) => {
      // 댓글 및 댓글 수 관련 쿼리를 취소
      await Promise.all([
        queryClient.cancelQueries({ queryKey: commentQueryKey.comments(idCardId) }),
        queryClient.cancelQueries({ queryKey: commentQueryKey.commentCount(idCardId) }),
      ]);

      // 이전 쿼리 데이터를 가져옴
      const previousComments = queryClient.getQueryData<CommentPages>(
        commentQueryKey.comments(idCardId),
      );

      const previousCommentCount = queryClient.getQueryData<CommentCountGetResponse>(
        commentQueryKey.commentCount(idCardId),
      );

      // 쿼리 데이터를 업데이트
      const updatedComments = removeCommentToPages(previousComments, commentInfo.commentId);
      queryClient.setQueryData(commentQueryKey.comments(idCardId), updatedComments);

      const updatedCommentCount = decreaseCommentCount(previousCommentCount);
      queryClient.setQueryData(commentQueryKey.commentCount(idCardId), updatedCommentCount);

      // 이전 쿼리 데이터를 반환. onError에서 사용할 수 있도록 함
      return { previousComments, previousCommentCount };
    },

    // API 호출에 오류가 발생했을 때 실행하는 함수
    onError: (err, newComment, context) => {
      // 이전 쿼리 데이터가 있으면
      if (context?.previousComments !== undefined && context?.previousCommentCount !== undefined) {
        // 에러를 토스트로 표시
        const error = err as AxiosError;
        errorToast(error.message);

        // 쿼리 데이터를 이전 상태로 복구
        queryClient.setQueryData(commentQueryKey.comments(idCardId), context.previousComments);
        queryClient.setQueryData(
          commentQueryKey.commentCount(idCardId),
          context.previousCommentCount,
        );
      }
    },
  });
};
//
export type CommentDeleteRequest = {
  idCardId: number;
  commentId: number;
};

```
- `useQueryClient()`를 가져와서, 이전에 실행한 댓글 및 댓글 수 관련 쿼리를 취소하고, 이전 쿼리 데이터를 가져왔다.
- `cancelQueries` : 쿼리를 취소하는 함수. `queryKey`를 전달하면 해당 쿼리를 취소한다.
- `getQueryData` : 쿼리 데이터를 가져오는 함수. `queryKey`를 전달하면 해당 쿼리 데이터를 가져온다.
- `setQueryData` : 쿼리 데이터를 업데이트하는 함수. `queryKey`와 업데이트할 데이터를 전달하면 해당 쿼리 데이터를 업데이트한다.
- 계속 등장하는 queryKey인 `CommentQueryKey.comments(idCardId)`는 어디 있느냐?

```js
// src/app/planet/[communityId]/id-card/[idCardId]/page.tsx
<HydrationProvider
  queryKey={commentQueryKey.comments(idCardId)}
  queryFn={getCommentsQuery}
>
  <CommentList idCardId={idCardId} />
</HydrationProvider>
```
- `HydrationProvider` 컴포넌트는 `useQuery` 훅을 사용해 쿼리 데이터를 가져오는 컴포넌트이다. `queryKey`와 `queryFn`을 전달하면 해당 쿼리 데이터를 가져온다.

### 사용법
```js
const { mutate: mutateDeleteComment } = useDeleteComment(idCardId);
const onClickToDeleteComment = () => {
  mutateDeleteComment({ idCardId, commentId });
};
```

## 2. [Axios Instance](https://github.dev/depromeet/ygtang-client)
```js
// axios와 관련된 타입들을 임포트합니다.
import axios, { AxiosError, AxiosResponse } from 'axios';

// 프로젝트 내의 다른 모듈들을 임포트합니다.
import { IS_PRODUCTION } from '~/constants/common';
import ApiException from '~/exceptions/ApiException';
import CustomException from '~/exceptions/CustomException';
import { errorMessage } from '~/exceptions/messages';
import { ApiErrorScheme } from '~/exceptions/type';

// 개발 환경과 프로덕션 환경에 따른 API URL을 지정합니다.
const DEVELOPMENT_API_URL = 'https://api.ygtang.xyz/api';
const PRODUCTION_API_URL = 'https://ygtang.kr/api';

// axios 인스턴스를 생성하며, baseURL, credentials, timeout 설정을 합니다.
export const instance = axios.create({
  baseURL: IS_PRODUCTION ? PRODUCTION_API_URL : DEVELOPMENT_API_URL,
  withCredentials: true,
  timeout: 15000,
});

// axios 요청에 사용할 토큰을 설정하는 함수입니다.
export function replaceAccessTokenForRequestInstance(token: string) {
  instance.defaults.headers.common['accessToken'] = token;
}

// 서버에서 응답이 성공적으로 이루어진 경우에 대한 인터셉터입니다.
// HTTP 상태 코드가 200에서 299사이인 경우에는 응답 데이터를 반환합니다.
function interceptorResponseFulfilled(res: AxiosResponse) {
  if (200 <= res.status && res.status < 300) {
    return res.data;
  }

  return Promise.reject(res.data);
}

// 서버에서 응닓이 실패한 경우에 대한 인터셉터입니다.
// 오류 메시지에 따라 다른 종류의 예외를 발생시킵니다.
function interceptorResponseRejected(error: AxiosError<ApiErrorScheme>) {
  if (error.response?.data?.message) {
    return Promise.reject(new ApiException(error.response.data, error.response.status));
  }

  if (error.message.startsWith('timeout')) {
    return Promise.reject(new CustomException(errorMessage.TIMEOUT, 'NETWORK_TIMEOUT'));
  }

  return Promise.reject(new CustomException(errorMessage.UNKNOWN_400, 'NETWORK_ERROR'));
}

// 응답에 대한 인터셉터를 설정합니다.
instance.interceptors.response.use(interceptorResponseFulfilled, interceptorResponseRejected);

// 각 HTTP 메소드에 대한 함수를 export 합니다.
export function get<T>(...args: Parameters<typeof instance.get>) {
  return instance.get<T, T>(...args);
}

export function post<T>(...args: Parameters<typeof instance.post>) {
  return instance.post<T, T>(...args);
}

export function put<T>(...args: Parameters<typeof instance.put>) {
  return instance.put<T, T>(...args);
}

export function patch<T>(...args: Parameters<typeof instance.patch>) {
  return instance.patch<T, T>(...args);
}

export function del<T>(...args: Parameters<typeof instance.delete>) {
  return instance.delete<T, T>(...args);
}

```

- 위 프로젝트의 특이점은 `get`, `post`, `put`, `patch`, `delete`를 커스텀으로 만들어었다는 것이다.

```js
export function get<T>(...args: Parameters<typeof instance.get>) {
  return instance.get<T, T>(...args);
}
```
- `get`함수를 사용하여, `instance.get`을 사용하듯이 사용할 수 있다.
- 또한, `...args`의 타입을 `Parameters<typeof instance.get>`을 설정하였다. 이는 `instance.get` 메소드가 받아들이는 모든 인자들의 타입을 튜플로 가져와서 args를 정의하는데 사용하는 것이다. 이를 통해 유연하게 여러 인자들을 받아들일 수 있도록 해준다.
- 사용 예시는 다음과 같다. 
```js
const fetchOpenGraph = (link: string): Promise<AxiosResponse<OpenGraphResponse>> => {
  const linkWithProtocol = getLinkWithProtocol(link);
  return get(`/v1/inspiration/link/availiable?link=${linkWithProtocol}`);
};
```
- 내가 지금 하고 있는 프로젝트의 경우 아래와같이 수행했다.
```js
export const postLogin = () => publicApi.post<LoginResponse>('/api/v1/auth/login', TEST_ID);
```
- `Promise<AxiosResponse<>>`로 둘러싸야 하는 것일까?
  - [기억보다 기록을](https://kyounghwan01.github.io/blog/TS/fundamentals/basic/#axios-response-call-interface)에서는 둘러싸라고 한다.
  - 사실, publicApi.post의 return값은 Promise이다. 그러니 둘러싸는 것이 맞다. 수정해야지.

## 3. useMutation
```js
// React Query의 useMutation 훅을 임포트합니다.
import { useMutation } from '@tanstack/react-query';

// 앞서 정의한 axios instance의 get 메소드를 임포트합니다.
import { get } from '~/libs/api/client';

// onSuccess, onError 메소드를 포함한 Props 인터페이스를 정의합니다.
interface UseCheckPasswordResetEmailVerifiedMutationProps {
  onSuccess?: (
    data: CheckPasswordResetEmailVerifiedMutationResponse,
    variables: CheckPasswordResetEmailVerifiedMutationParams,
    context: unknown
  ) => void | Promise<unknown>;
  onError?: (
    data: { message?: string },
    variables: CheckPasswordResetEmailVerifiedMutationParams,
    context: unknown
  ) => void | Promise<unknown>;
}

// 비밀번호 초기화 이메일 검증 API 호출에 사용될 변수의 타입을 정의합니다.
export interface CheckPasswordResetEmailVerifiedMutationParams {
  email: string;
}

// 비밀번호 초기화 이메일 검증 API 호출의 응답 타입을 정의합니다.
export interface CheckPasswordResetEmailVerifiedMutationResponse {
  message: string;
  data: boolean;
}

/**
 * 비밀번호 초기화를 위한 해당 이메일의 인증 상태 여부를 반환하는 훅입니다.
 */
export default function useCheckPasswordResetEmailVerifiedMutation({
  onSuccess,
  onError,
}: UseCheckPasswordResetEmailVerifiedMutationProps) {
  // useMutation 훅을 사용하여 API 호출을 정의합니다. 
  // 첫 번째 인자는 API 호출 함수, 두 번째 인자는 옵션 객체입니다.
  return useMutation<
    CheckPasswordResetEmailVerifiedMutationResponse, // 응답 데이터의 타입
    { message?: string }, // 오류 데이터의 타입
    CheckPasswordResetEmailVerifiedMutationParams // API 호출 변수의 타입
  >(
    // API 호출 함수를 정의합니다.
    ({ email }: CheckPasswordResetEmailVerifiedMutationParams) =>
      get<CheckPasswordResetEmailVerifiedMutationResponse>(
        `/v1/auth/passwords/reset/email/${email}/status`
      ),
    // 옵션 객체를 전달합니다. 여기에는 성공 및 오류 시의 콜백 함수가 포함됩니다.
    { onSuccess, onError }
  );
}

```
- `UseCheckPasswordResetEmailVerifiedMutationProps` 정말 길다. 8개의 단어가 합쳐져 있다. 상당히 가독성이 안좋다. 
- `useMutation`의 props를 정의하였다. onSuccess와 onError, 위의 긴 변수명이 이 두 callback함수의 interface이다.
- 아래는 위에서 선언한 `mutation`을 사용하는 코드이다.

```js
const { mutate: checkMutate } = useCheckPasswordResetEmailVerifiedMutation({
  onSuccess: data => {
    if (data.data && queryEmail) {
      sendMutate({
        email: queryEmail,
      });
    } else {
      setIsError(true);
      fireToast({
        content: '이메일 전송에 실패했습니다. (' + data.message + ')',
        duration: 5000,
      });
    }
  },
  onError: data => {
    fireToast({ content: '이메일 전송에 실패했습니다. (' + data.message + ')', duration: 5000 });
    setIsError(true);
  },
});
```
- 위 코드처럼 onSuccess 및 onError을 `useMutation`의 인자로 넘겨서 처리할 수가 있구나.

## 4. useDidMount
```js
import { EffectCallback, useEffect, useRef } from 'react';

// useDidMount라는 이름의 사용자 정의 훅을 정의합니다. 이 훅은 EffectCallback 타입의 인자를 받습니다.
export default function useDidMount(effectCallback: EffectCallback) {
  // didMountRef라는 이름의 ref를 만들고, 초기값으로 false를 지정합니다. 이 ref는 컴포넌트가 처음 마운트되었는지 여부를 추적합니다.
  const didMountRef = useRef<boolean>(false);

  // useEffect 훅을 사용하여 사이드 이펙트를 처리합니다.
  useEffect(() => {
    // 만약 didMountRef.current가 true라면 (즉, 컴포넌트가 이미 마운트되었다면) 아무런 작업도 수행하지 않고 종료합니다.
    if (didMountRef.current) return;
    // didMountRef.current를 true로 설정하여, 컴포넌트가 마운트되었음을 표시합니다.
    didMountRef.current = true;
    // effectCallback 함수를 실행합니다. 이 함수는 컴포넌트가 처음 마운트되었을 때만 실행됩니다.
    effectCallback();
  }, [effectCallback]); // effectCallback이 변경될 때마다 이 사이드 이펙트를 새로 수행합니다.
}

```
- `useDidMount` 훅은 `useEffect`훅과 달리 컴포넌트가 처음으로 마운트되었을 때만 콜백 함수를 실행한다. 따라서, 이 훅을 사용하여 컴포넌트가 업데이트될 때마다 콜백이 불필요하게 실행되는 것을 방지할 수 있다.
- `useRef`와 `useState`는 모두 React에서 상태를 관리하기 위해 사용되지만, 각각의 훅은 약간 다른 목적을 가지고 있다.
- `useState`는 컴포넌트의 상태를 관리하고 그 상태가 변경될 때마다 컴포넌트를 다시 렌더링하는 데 사용된다. 이는 상태 값이 **사용자 인터페이스에 직접적으로 영향을 미치는 경우**에 유용하다.

- 반면에 `useRef`는 **변경 가능한 값을 보존할 수 있는 "상자" 역할**을 합니다. `useRef`가 반환하는 객체(`ref`)는 `.current` 프로퍼티를 가지고 있으며, 이 프로퍼티는 **변경될 때마다 컴포넌트를 다시 렌더링하지 않는다**. 이는 상태 값이 사용자 인터페이스에 영향을 미치지 않고, 컴포넌트 렌더링 사이에 값을 유지해야 하는 경우에 유용하다.

- `useDidMount` 훅에서 `useRef`가 사용되는 이유는, 컴포넌트의 마운트 상태를 추적하고자 하는 것이지만, 이 상태가 변경될 때마다 컴포넌트를 렌더링하지 않기 때문이다. 즉, `didMountRef.current` 값의 변경은 렌더링을 발생시키지 않으며, 이는 이 상태가 UI에 직접적으로 영향을 미치지 않기 때문이다. 이렇게 하면 컴포넌트가 처음 마운트되었을 때만 `effectCallback`이 호출되는 것을 보장할 수 있다.
- `mount`는 컴포넌트가 처음 페이지에 추가되었을 때, `render`는 컴포넌트의 상태가 변했을 때 일어남.

- 사용 예시

```js
useDidMount(() => {
  if (queryEmail && queryEmail !== '') {
    checkMutate({
      email: queryEmail,
    });
  }
});
```

## 5. Query Key 관리
```js
export const commentQueryKey = {
  comments: (idCardId: number) => ['comments', idCardId],
  commentReplies: (idCardId: number, commentId: number) => ['replies', idCardId, commentId],
  commentCount: (idCardId: number) => ['commentCount', idCardId],
};
```
- 객체 형태로 관리 -> 유지 보수에 용이
- 사용 예시
```js
commentQueryKey.comments(idCardId)  // ['comments', idCardId]
```