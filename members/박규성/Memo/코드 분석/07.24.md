# 07.24
## 1. [Component Composition](https://velog.io/@jangws/React-Context%EA%B0%80-%EA%BC%AD-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C-props-drilling%EC%9D%84-%EA%B7%B9%EB%B3%B5%ED%95%B4%EB%B3%B4%EC%9E%90)
```js
import React from 'react';

// ParentBox라는 컴포넌트를 생성합니다. 이 컴포넌트는 자식 컴포넌트들(children)을 prop으로 받습니다.
const ParentBox = ({ children }) => {

  // React.Children.toArray 함수를 이용해 자식 컴포넌트들을 배열로 변경합니다.
  const flattenChildren = React.Children.toArray(children);

  // 자식 컴포넌트의 onChange 이벤트 발생 시 실행될 부모 함수를 정의합니다.
  // 이 함수는 이벤트 객체를 콘솔에 로깅합니다.
  const parentFunc = (e) => {
    console.log(e, '여기에서는 자식 인풋 onChange 이벤트에 추가할 함수를 작성할 수 있다');
  };

  // 자식 컴포넌트의 onChange 콜백 함수와 부모 함수를 합성하는 함수를 정의합니다.
  // 이 함수는 onChange 이벤트가 발생할 때마다 자식 컴포넌트의 onChange 콜백 함수를 먼저 호출한 뒤, 부모 함수를 호출합니다.
  const compositeOnChange = (callback) => (e) => {
    callback(e);
    parentFunc(e);
  };

  // 자식 컴포넌트들을 순회하면서, 각 컴포넌트가 input인 경우에만 onChange 콜백 함수를 합성 함수로 변경합니다.
  // 만약 자식 컴포넌트가 input이 아닌 경우에는 원래의 컴포넌트를 반환합니다.
  const changedChildren = flattenChildren.map((child) => {
    if (child.type?.target === 'input') {
      return {
        ...child,
        props: {
          ...child.props,
          onChange: compositeOnChange(child.props.onChange),
        },
      };
    }
    return child;
  });

  // 변경된 자식 컴포넌트들을 반환합니다.
  return <>{changedChildren}</>;
};

```
- `React.Children.toArray(children)` : children을 평평하게 만들어 1차원 배열로 변환하여 return한다.

### 사용법
```js
<ParentBox>
  <input onChange={onChangeInput} />
  <input onChange={onChangeInput} />
  <input onChange={onChangeInput} />
</ParentBox>;
```


## 2. [useTimer](https://github.com/thibaultboursier/use-timer)
```js
// useTimer.ts
import reducer from './reducer';
import { useCallback, useEffect, useReducer } from 'react';
import type { ReturnType, UseTimerProps } from './type';

// 타이머 훅을 선언합니다. 해당 훅은 UseTimerProps 타입의 속성들을 받습니다.
// 반환 타입은 ReturnType입니다.
const useTimer = ({
  autostart = false,
  endTime,
  initialStatus = 'STOPPED',
  initialTime = 0,
  interval = 1000,
  onTimeOver,
  onTimeUpdate,
  step = 1,
  timerType = 'DECREMENTAL',
}: Partial<UseTimerProps> = {}): ReturnType => {
  // useReducer 훅을 사용하여 상태 관리를 합니다. 초기 상태는 status, time, timerType으로 구성됩니다.
  const [state, dispatch] = useReducer(reducer, {
    status: initialStatus,
    time: initialTime,
    timerType,
  });

  const { status, time } = state;

  // 시간을 진행시키는 함수를 선언합니다.
  const advanceTime = useCallback((timeToAdd: number) => {
    dispatch({ type: 'advanceTime', payload: { timeToAdd } });
  }, []);

  // 타이머를 일시 정지시키는 함수를 선언합니다.
  const pause = useCallback(() => {
    dispatch({ type: 'pause' });
  }, []);

  // 타이머를 초기화하는 함수를 선언합니다.
  const reset = useCallback(() => {
    dispatch({ type: 'reset', payload: { initialTime } });
  }, [initialTime]);

  // 타이머를 시작하는 함수를 선언합니다.
  const start = useCallback(() => {
    dispatch({ type: 'start', payload: { initialTime } });
  }, [initialTime]);

  // 컴포넌트가 마운트 되었을 때, autostart가 true라면 타이머를 시작합니다.
  useEffect(() => {
    if (autostart) {
      dispatch({ type: 'start', payload: { initialTime } });
    }
  }, [autostart, initialTime]);

  // time 값이 변할 때마다, onTimeUpdate 콜백 함수를 호출합니다.
  useEffect(() => {
    if (typeof onTimeUpdate === 'function') {
      onTimeUpdate(time);
    }
  }, [time, onTimeUpdate]);

  // status나 time 값이 변할 때마다, endTime에 도달하면 타이머를 멈추고 onTimeOver 콜백을 실행합니다.
  useEffect(() => {
    if (status !== 'STOPPED' && time === endTime) {
      dispatch({ type: 'stop' });

      if (typeof onTimeOver === 'function') {
        onTimeOver();
      }
    }
  }, [endTime, onTimeOver, time, status]);

  // status나 time 값이 변할 때마다, status가 'RUNNING'일 경우에는 interval에 따라 시간을 진행하거나 줄입니다.
  // status가 'RUNNING'이 아닐 경우에는 interval을 멈춥니다.
  useEffect(() => {
    let intervalId: NodeJS.Timeout | null = null;

    if (status === 'RUNNING') {
      intervalId = setInterval(() => {
        dispatch({
          type: 'set',
          payload: {
            newTime: timerType === 'DECREMENTAL' ? time - step : time + step,
          },
        });
      }, interval);
    } else if (intervalId) {
      clearInterval(intervalId);
    }

    // 컴포넌트가 언마운트 되거나, useEffect가 종료되는 경우 interval을 멈춥니다.
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [status, step, timerType, interval, time]);

  // 훅이 반환하는 값입니다. 상태 값과 액션을 실행하는 함수들을 반환합니다.
  return { advanceTime, pause, reset, start, status, time };
};

export default useTimer;


```
- 너무 코드가 많으니 하나만 살펴보자.

```js
// useTimer.ts
const start = useCallback(() => {
  dispatch({ type: 'start', payload: { initialTime } });
}, [initialTime]);

// actions.ts
const START = (initialTime: number) => createActionType('start', { initialTime });

// reducer.ts
switch (action.type) {
  case 'start': {
    const { initialTime } = action.payload;

    return {
      ...state,
      status: 'RUNNING',
      time: state.status === 'STOPPED' ? initialTime : state.time,
    };
  }
}

```
1. `dispatch`를 통해 `action`을 `reducer`에게 전달한다. 어떤 action이냐면 type은 `start`이고, payload는 `{ initialTime }`이다. 이 `initialTime`은 props로 받은 값이다.
2. `action`에는 `type`과 `payload`가 있다. `type`은 `start`이고, `payload`는 `{ initialTime }`이다. 
3. `action`이 `reducer`에게 전달되었다. `reducer`는 action.type이 `start`일 경우, `initialTime`을 `payload`로 받아서 `state`의 `time`에 할당한다. 그리고 `status`를 `RUNNING`으로 변경한다.
4. `state`가 변경이 되었고, 이제 변경된 `state`는 화면에 보여진다.
- 위 과정이 바로 `flux`패턴이다.


## 3. [step 구조](https://github.dev/depromeet/Ding-dong-fe)
```js
// page.tsx
import { IdCardCreationSteps } from '~/modules/IdCardCreation';

type IdCardCreationPageProps = {
  params: {
    communityId: string;
  };
};

const IdCardCreationPage = ({ params: { communityId } }: IdCardCreationPageProps) => {
  return (
    <>
      <main>
      <IdCardCreationSteps communityId={Number(communityId)} />
      </main>
      <div className="h-[50px] bg-white" />
    </>
  );
};

export default IdCardCreationPage;

```
- 서버 컴포넌트로, uri의 params를 받아와 메인 컴포넌트인 `IdCardCreationSteps`에 넘겨준다.

```js
// IdCardCreationSteps.tsx

const INIT_STEP = 0;

const steps: CreationSteps[] = ['BOARDING', 'PROFILE', 'KEYWORD', 'KEYWORD_CONTENT', 'COMPLETE'];

const CHARACTER_DEFAULT_KEYWORD = {
  BUDDY: '아이디어 뱅크',
  TOBBY: '자유로운 영혼',
  PIPI: '모두의 뮤즈',
  TRUE: '현실주의자',
};

export const idCardCreationSchema = yup.object({
  profileImageUrl: yup.string(),
  communityId: yup.number(),
  nickname: yup.string().required('이름을 입력해 주세요.'),
  aboutMe: yup.string(),
  keywords: yup.array().min(1).default([]).required(),
});

type IdCardCreationStepsProps = {
  communityId: number;
};

export const IdCardCreationSteps = ({ communityId }: IdCardCreationStepsProps) => {
  const { errorToast } = useToastMessageStore();
  const { data } = useGetUserInfo();
  const profileImageUrl = data?.userProfileDto.profileImageUrl;
  const characterType = data?.userProfileDto.characterType || 'BUDDY';
  const router = useRouter();
  const pathname = usePathname();

  const defaultKeywordByCharacter = {
    title: CHARACTER_DEFAULT_KEYWORD[characterType],
    imageUrl: '',
    content: '',
  };

  const methods = useForm<IdCardCreationFormModel>({
    defaultValues: {
      communityId,
      profileImageUrl,
      nickname: '',
      aboutMe: '',
      keywords: [defaultKeywordByCharacter],
    },
    mode: 'onChange',
    resolver: yupResolver(idCardCreationSchema),
  });
  const [idCardId, setIdCardId] = useState<number>();

  const [stepOrder, setStepOrder] = useState<number>(INIT_STEP);
  const onNext = () => setStepOrder(stepOrder + 1);
  const onPrev = () => setStepOrder(stepOrder - 1);

  const { mutateAsync } = usePostIdCardCreate({
    onSuccess: data => {
      setIdCardId(data.id);
    },
    onError: error => {
      errorToast(error.message);
      setTimeout(() => {
        const planetIdPathname = pathname.replace('/id-card/create', '');
        router.push(`${planetIdPathname}`);
      }, 2000);
    },
  });

  //TODO: Extract logic of sending complete step to router
  const { data: checkIdCard } = useCheckIdCards(communityId);
  const { data: idCardDetails } = useGetCommunityMyIdCardDetail(communityId, {
    enabled: !!checkIdCard?.userMakeIdCard,
  });

  useLayoutEffect(() => {
    if (!checkIdCard?.userMakeIdCard || !idCardDetails || stepOrder === steps.length - 1) {
      return;
    }
    const { idCardId, profileImageUrl, nickname, aboutMe, keywords } =
      idCardDetails.idCardDetailsDto;
    const transformedKeywords = keywords.map(keyword => {
      return { title: keyword.title, imageUrl: keyword.imageUrl, content: keyword.content };
    });

    setIdCardId(idCardId);
    methods.setValue('profileImageUrl', profileImageUrl);
    methods.setValue('nickname', nickname);
    methods.setValue('aboutMe', aboutMe);
    methods.setValue('keywords', transformedKeywords);
    setStepOrder(steps.length - 1);
  }, [checkIdCard, checkIdCard?.userMakeIdCard, idCardDetails, methods, stepOrder]);

  const onSubmit = () => {
    methods.handleSubmit(async data => {
      await mutateAsync(data);
    })();
    onNext();
  };

  return (
    <FormProvider {...methods}>
      {/* planetName 주입이 필요합니다. */}
      <div>
        {steps[stepOrder] === 'BOARDING' && <BoardingStep onNext={onNext} />}
        {['PROFILE', 'KEYWORD', 'KEYWORD_CONTENT'].includes(steps[stepOrder]) && (
          <IdCardCreationForm
            steps={steps}
            stepOrder={stepOrder}
            onNext={onNext}
            onPrev={onPrev}
            onSubmit={onSubmit}
          />
        )}
        {steps[stepOrder] === 'COMPLETE' && idCardId && <CompleteStep idCardId={idCardId} />}
      </div>
    </FormProvider>
  );
};

```
1. `const { errorToast } = useToastMessageStore();`
  - `toastMessage`의 경우 전역 상태로 관리하고 있다.
2. `const { data } = useGetUserInfo();`
   - `useQuery`로 data를 받아온다.
   - 이 데이터를 현재 client에서 받아오는데, server에서 미리 받아서 렌더링하는 것이 더 나은 방식이라 생각한다.
3. `const profileImageUrl = data?.userProfileDto.profileImageUrl`
    `const characterType = data?.userProfileDto.characterType || 'BUDDY';`
      - 위의 `useQuery`를 통해 받아온 `data`를 통해 `profileImageUrl`과 `characterType`을 받아온다. 
4. 
```js
  const { mutateAsync } = usePostIdCardCreate({
    onSuccess: data => {
      setIdCardId(data.id);
    },
    onError: error => {
      errorToast(error.message);
      setTimeout(() => {
        const planetIdPathname = pathname.replace('/id-card/create', '');
        router.push(`${planetIdPathname}`);
      }, 2000);
    },
  });
  ```
  - `useMutation`을 통해 `mutateAsync`를 가져온다.
  - 이 때, `useMutation`의 인자로 `onSuccess`, `onError` callback 함수를 넘겨주어 `mutateAsync`가 성공했을 때, 실패했을 때의 로직을 작성한다.
  - `mutate`는 아무 것도 반환하지 않는 반면, `mutateAsync`는 변형 결과가 포함된 Promise를 반환합니다.
5. 
```js
   useLayoutEffect(() => {
    if (!checkIdCard?.userMakeIdCard || !idCardDetails || stepOrder === steps.length - 1) {
      return;
    }
    const { idCardId, profileImageUrl, nickname, aboutMe, keywords } =
      idCardDetails.idCardDetailsDto;
    const transformedKeywords = keywords.map(keyword => {
      return { title: keyword.title, imageUrl: keyword.imageUrl, content: keyword.content };
    });

    setIdCardId(idCardId);
    methods.setValue('profileImageUrl', profileImageUrl);
    methods.setValue('nickname', nickname);
    methods.setValue('aboutMe', aboutMe);
    methods.setValue('keywords', transformedKeywords);
    setStepOrder(steps.length - 1);
  }, [checkIdCard, checkIdCard?.userMakeIdCard, idCardDetails, methods, stepOrder]);
  ```
  - `useLayoutEffect`는 `useEffect`와 비슷하지만, `useEffect`는 렌더링이 끝난 후에 실행되는 반면, `useLayoutEffect`는 렌더링이 끝나기 전에 실행된다.
  - ID 카드 체크와 세부 정보가 바뀔 때마다 폼 값을 설정하고 단계를 업데이트한다.


### Step을 이용한 페이지 구분
```js
const steps: CreationSteps[] = ['BOARDING', 'PROFILE', 'KEYWORD', 'KEYWORD_CONTENT', 'COMPLETE'];
const INIT_STEP = 0;
// ...
const [stepOrder, setStepOrder] = useState<number>(INIT_STEP);
const onNext = () => setStepOrder(stepOrder + 1);
const onPrev = () => setStepOrder(stepOrder - 1);

const onSubmit = () => {
  methods.handleSubmit(async data => {
    await mutateAsync(data);
  })();
  onNext();
};
<div>
  {steps[stepOrder] === 'BOARDING' && <BoardingStep onNext={onNext} />}
  {['PROFILE', 'KEYWORD', 'KEYWORD_CONTENT'].includes(steps[stepOrder]) && (
    <IdCardCreationForm
      steps={steps}
      stepOrder={stepOrder}
      onNext={onNext}
      onPrev={onPrev}
      onSubmit={onSubmit}
    />
  )}
  {steps[stepOrder] === 'COMPLETE' && idCardId && <CompleteStep idCardId={idCardId} />}
</div>
```
- number타입의 `stepOrder`을 선언한다. 이는 step의 index값이다.
- `onSubmit`은 제출하는 버튼을 눌렀을 때 실행되는 함수이므로 `onNext`를 실행한다.
- 컴포넌트의 인자로 `onNext`, `onPrev`을 넘겨준다.
- `step[stepOrder]`는 `stepOrder`에 해당하는 `step`을 의미한다.
- 이 step이 첫 단계, 즉 `BOARDING`일 경우 `BoardingStep`을 렌더링한다.
- 이 step이 마지막 단계, 즉 `COMPLETE`일 경우 `CompleteStep`을 렌더링한다.

```js
// IdCardCreateForm.tsx
'use client';
import { FormEvent } from 'react';
import { useFormContext } from 'react-hook-form';

import { TopNavigation } from '~/components/TopNavigation';
import { CreationSteps } from '~/modules/IdCardCreation/IdCardCreation.type';
import { KeywordStep } from '~/modules/IdCardCreation/Step/KeywordStep.client';
import { IdCardCreationFormModel } from '~/types/idCard';
import { tw } from '~/utils/tailwind.util';

import { KeywordContentStep, ProfileStep } from '../Step';

type IdCardCreationFormProps = {
  steps: CreationSteps[];
  stepOrder: number;
  onNext: () => void;
  onPrev: () => void;
  onSubmit: () => void;
};

const disableButtonStyle = 'text-grey-400';

export const IdCardCreationForm = ({
  steps,
  stepOrder,
  onNext,
  onPrev,
  onSubmit,
}: IdCardCreationFormProps) => {
  const {
    formState: { errors, isDirty, isValid, isSubmitting },
  } = useFormContext<IdCardCreationFormModel>();

  const getNavigationButton = () => {
    let error;
    let disableStyle;
    switch (steps[stepOrder]) {
      case 'PROFILE':
        error = !isDirty || !!errors?.nickname || !isValid;
        disableStyle = (error && disableButtonStyle) || '';
        return (
          <button className={disableStyle} disabled={error} onClick={onNext}>
            다음
          </button>
        );
      case 'KEYWORD':
        disableStyle = (!isValid && disableButtonStyle) || '';
        return (
          <button className={disableStyle} disabled={!isValid} onClick={onNext}>
            다음
          </button>
        );
      case 'KEYWORD_CONTENT':
        disableStyle = (!isValid && disableButtonStyle) || '';
        return (
          <button
            className={tw(disableStyle, 'submission')}
            disabled={!isValid || isSubmitting}
            onClick={onSubmit}
          >
            제출
          </button>
        );
      default:
        return null;
    }
  };
  const NavigationButton = getNavigationButton();

  return (
    <div>
      <TopNavigation>
        <TopNavigation.Left>
          <TopNavigation.BackButton onClickBackButton={onPrev} />
        </TopNavigation.Left>
        <TopNavigation.Title />
        <TopNavigation.Right className="text-h5 text-primary-500">
          {NavigationButton}
        </TopNavigation.Right>
        <TopNavigation.ProgressBar currentStep={stepOrder} stepsLength={3} />
      </TopNavigation>

      <form className="pt-24pxr" onSubmit={(e: FormEvent<HTMLFormElement>) => e.preventDefault()}>
        {steps[stepOrder] === 'PROFILE' && <ProfileStep />}
        {steps[stepOrder] === 'KEYWORD' && <KeywordStep />}
        {steps[stepOrder] === 'KEYWORD_CONTENT' && <KeywordContentStep />}
      </form>
    </div>
  );
};

```

### Step 단계
```js
<form className="pt-24pxr" onSubmit={(e: FormEvent<HTMLFormElement>) => e.preventDefault()}>
  {steps[stepOrder] === 'PROFILE' && <ProfileStep />}
  {steps[stepOrder] === 'KEYWORD' && <KeywordStep />}
  {steps[stepOrder] === 'KEYWORD_CONTENT' && <KeywordContentStep />}
</form>
```
- `onSubmit`함수는 넘겨받은 `onSubmit`함수를 실행한다.
- `steps[stepOrder]`에 따라 각각 다른 컴포넌트를 보여준다.