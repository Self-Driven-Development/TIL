# 7.21
## 1. api config 설정 (Gloddy 프로젝트)
```js
// apis/config/privateApi.ts
import { onRequestError, onResponse, onResponseError } from './interceptor';
import { onRequestClient } from './interceptor.client';
import { BASE_API_URL } from '@/constants';
import axios from 'axios';

import type { CustomInstance } from './type';

const privateApi: CustomInstance = axios.create({
  baseURL: BASE_API_URL,
  withCredentials: true,
});

privateApi.interceptors.request.use(onRequestClient, onRequestError);

privateApi.interceptors.response.use(onResponse, onResponseError);

export default privateApi;


// apis/config/interceptor.ts
import { ApiError } from './customError';
import { ErrorType } from './type';
import { AxiosError, AxiosResponse, InternalAxiosRequestConfig } from 'axios';

export const onRequestError = (error: AxiosError) => {
  Promise.reject(error);
};

export const onResponse = (response: AxiosResponse) => {
  return response.data;
};

export const onResponseError = (error: AxiosError<ErrorType, InternalAxiosRequestConfig>) => {
  if (error.response) {
    const data = error.response.data;
    const { success, statusCode, errorCode, reason } = data;
    console.log(data);
    return Promise.reject(new ApiError(success, statusCode, errorCode, reason));
  }
  if (error.request) console.log(error.request);
  else console.log('Error', error.message);

  return Promise.reject(new Error('요청 도중 에러 발생'));
};

// apis/config/interceptor.client.ts
import { postLogin } from '../auth';
import { InternalAxiosRequestConfig } from 'axios';

export const onRequestClient = async (config: InternalAxiosRequestConfig) => {
  try {
    const data = await postLogin();
    const token = data.token;

    if (token) {
      config.headers['X-AUTH-TOKEN'] = token;
      return config;
    }
    throw new Error('로그인이 필요합니다.');
  } catch (error) {
    return Promise.reject(error);
  }
};

// api/config/customeError.ts
export class ApiError extends Error {
  success: boolean;
  statusCode: number;
  errorCode: string;
  reason: string;
  constructor(success: boolean, statusCode: number, errorCode: string, message: string) {
    super(message);
    this.success = success;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.reason = message;
  }
}

// apis/config/type.ts
import {
  AxiosInstance,
  AxiosInterceptorManager,
  AxiosResponse,
  InternalAxiosRequestConfig,
} from 'axios';

export type CustomResponseFormat<T = any> = T;

export interface CustomInstance extends AxiosInstance {
  interceptors: {
    request: AxiosInterceptorManager<InternalAxiosRequestConfig>;
    response: AxiosInterceptorManager<AxiosResponse<CustomResponseFormat>>;
  };
  get<T>(...params: Parameters<AxiosInstance['get']>): Promise<T>;
  delete<T>(...params: Parameters<AxiosInstance['delete']>): Promise<T>;
  post<T>(...params: Parameters<AxiosInstance['post']>): Promise<T>;
  put<T>(...params: Parameters<AxiosInstance['put']>): Promise<T>;
  patch<T>(...params: Parameters<AxiosInstance['patch']>): Promise<T>;
}

export type ErrorType = {
  success: boolean;
  statusCode: number;
  errorCode: string;
  reason: string;
};


```
- `privateApi`를 `CustomInstance`타입으로 정의하였다. customInstance는 `AxiosInstance`타입을 확장한 타입으로, `interceptors.request`, `interceptors.response`, get, delete, post, put, patch 등의 메소드를 가지고 있다. 이에 대한 타입을 명확히 해주었다.
- `onRequestClient`, `onRequestError`, `onResponse`, `onResponseError`는 api instance를 생성할 때 interceptor로 등록되는 함수들이다.
- `onRequestClient` : 요청을 보내기 전에 실행되는 함수이다.
  - 요청을 보내기 전에, `postLogin`함수를 이용하여 `token`을 받아온다. 받아온 `token`을 `config.headers['X-AUTH-TOKEN']`에 넣어준다. 
  - `token`이 없다면, `Error`를 발생시킨다.
  - `token`이 있다면, `config`를 반환한다.
  - 현재는 매 요청마다 로그인을 하여(Test 계정으로) 토큰을 받아오지만, 추후에는 `refreshToken`을 쿠키/스토리지에 저장하여 이 값을 이용하여 토큰을 받아오는 방식으로 변경할 예정이다. 쿠키/스토리지 접근 방식이 server측과 client측이 다르므로 `interceptor.client`와 `interceptor.server`를 분리하여 관리할 예정이다.
  - 이 때, 인자로 `config`를 받았는데 이 타입은 `InternalAxiosRequestConfig`로 타입을 정의해주었다. `axios`에서 제공하는 타입이다.

- `onRequestError` : 요청을 보내기 전에 에러가 발생하면 실행되는 함수이다. 현재는 에러가 발생하면 `Promise.reject`를 반환하도록 하였다.
- `onResponse` : 요청을 보내고 응답을 받은 후 실행되는 함수이다. 현재는 응답을 받은 후 `response.data`를 반환하도록 하였다. 
  - 응답 데이터에 대한 처리는 각 데이터마다 다르기에 공통으로 처리할 수 있는 부분이 없어 큰 변동 없을 것이다,
- `onResponseError` : 응답이 에러일 경우에 대한 처리이다. 에러가 발생하면 `Promise.reject`를 반환하도록 하였다. 
  - 추후 백엔드와 이야기 후 에러 code에 대한 에러핸들링을 추가할 예정이다. 예를 들어 401에러이면 로그인 화면으로 `redirect`, 404에러이면 404페이지로 `redirect`하는 식으로 말이다.

## 2. Label.tsx(Radix-UI)
```js
import * as React from 'react';
import { Primitive } from '@radix-ui/react-primitive';

import type * as Radix from '@radix-ui/react-primitive';

/* -------------------------------------------------------------------------------------------------
 * Label
 * -----------------------------------------------------------------------------------------------*/

const NAME = 'Label';

type LabelElement = React.ElementRef<typeof Primitive.label>;
type PrimitiveLabelProps = Radix.ComponentPropsWithoutRef<typeof Primitive.label>;
interface LabelProps extends PrimitiveLabelProps {}

const Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {
  return (
    <Primitive.label
      {...props}
      ref={forwardedRef}
      onMouseDown={(event) => {
        props.onMouseDown?.(event);
        // prevent text selection when double clicking label
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }}
    />
  );
});

Label.displayName = NAME;

/* -----------------------------------------------------------------------------------------------*/

const Root = Label;

export {
  Label,
  //
  Root,
};
export type { LabelProps };

```
- React UI 라이브러리인 Radix-UI의 `Label.tsx`이다. 그나마 짧은 코드를 가져왔는데, 이마저도 이해가되지 않아 Chat GPT에게 물어보았다.

## 1. `onMouseDown`
```js
onMouseDown={(event) => {
  props.onMouseDown?.(event);
  // prevent text selection when double clicking label
  if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
}}
```
- `Primitive.Label`에 넘겨준 이 코드는, 사용자가 라벨 컴포넌트를 더블 클릭하여 발생하는 텍스트 자동 선택을 방지하는 역할을 한다. HTML에서 더블 클릭은 텍스트를 자동으로 선택하는 기본 동작인데, 이 동작을 원치 않기에 마우스 클릭 횟수(`event.detail`)이 1보다 큰 경우 `preventDefault`를 실행하여 이 동작을 방지한다.


## 2. `React.forwardRef`
```js
const Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {
  return (
    <Primitive.label
    // ...
      ref={forwardedRef}
    />
  );
})
```
- React에서 `ref`는 컴포넌트에 대한 직접적인 접근을 가능하게하는 수단이다. DOM 요소에 대한 참조를 보관할 수 있다. 함수형 컴포넌트는 자체적으로 인스턴스를 가지지 않기 때문에 `ref`를 직접 상요할 수 없다. 대신에 React는 `React.ForwardRef`라는 API를 제공하여 함수형 컴포넌트에서 `ref`를 받아서 내부의 DOM요소나 다른 클래스 컴포넌트에 전달(forward)할 수 있도록 한다.
- 위 코드에서는 `React.forwardRef`를 사용하여 `label`컴포넌트에서 `ref`를 받아서 `Primitive.label`컴포넌트에 전달하고 있다. 이렇게 하면 `Label`컴포넌트를 사용하는 곳에서 `ref`를 사용할 수 있게 된다. 이를 통해 예를 들어, 해당 DOM 요소에 포커스를 주거나, 해당 요소의 크기나 위치 정보를 가져오는 등의 작업을 수행할 수 있다.

### 3. `<LabelElement, LabelProps>`
```js
const Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef)=>{return()})
```
- `React.forwardRef`의 첫 번째 인자(`LabelElement`)는 `ref`를 전달받을 DOM 요소의 타입을 정의한다. `ReactElementRef<typeof Primitive.label>`은 `Prmitive.label`컴포넌트의 실제 인스턴스 형태를 나타내는 타입이다. 이를 통해 이 컴포넌트를 사용하는 사용자가 반환된 ref를 통해 어던 메서드나 프로퍼티에 접근할 수 잇는 지 알 수 있다.
- 두 번째 인자는 `props`의 타입을 정의한다. `Primitive.label`컴포넌트가 받을 수 있는 props의 타입을 정의한다. 이를 통해 `Primitive.label`컴포넌트를 사용하는 사용자가 `Label`컴포넌트에 어떤 props를 넘겨줄 수 있는 지 알 수 있다.


이 코드만 봐서는 완전히 이해가 가지 않는다. 그렇다면, 위 `Label` 컴포넌트를 사용한 코드를 한 번 살펴보자. `Select`, `RadioGroup`, `Menubar`, `Menu`, `Form` 등에서 활용하였다. `Redix-UI`에서는 `Label`컴포넌트를 storybook에서밖에 활용하지 않고 있다. 아래와 같은 식으로 말이다.
```js
<Label>
  Label{' '}
  <Checkbox.Root className={rootClass()}>
    <Checkbox.Indicator className={indicatorClass()} />
  </Checkbox.Root>
</Label>
```
그래서 chatGPT에게 코드를 짜달라고 부탁하였다.

### `Label`의 활용
```js
import * as React from 'react';
import { Label, LabelProps } from './Label'; 

const ColorChangingLabel: React.FC<LabelProps> = (props) => {
  const labelRef = React.useRef<HTMLLabelElement>(null);

  const handleClick = () => {
    if (labelRef.current) {
      labelRef.current.style.color = labelRef.current.style.color === 'red' ? 'black' : 'red';
    }
  };

  return <Label {...props} ref={labelRef} onClick={handleClick} />;
};

export default ColorChangingLabel;

```
- `Label`컴포넌트에 `labelRef`를 `Label`에 넘겨줌으로써 컴포넌트 바깥에서도 `label`의 DOM요소에 접근할 수 있게 되었다. 이를 통해 `label`의 `style`을 변경하는 코드를 작성하였다.