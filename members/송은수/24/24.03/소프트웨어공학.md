---
title: '소프트웨어공학'
---

# no Silver Bullet

## 요약해보기

소프트웨어에는 은총알이 존재하지 않는다.

첫째. 하드웨어의 발전이 너무나도 빠르다. 역사에서 성능과 가격하락이 동시에 일어난 예는 거의 없다.

둘째. 소프트웨어는 알고리즘 설계, 데이터 간의 관계, 함수의 호출 등 다양한 문제들이 결합되어 만들어진다. 이 부분은 굉장히 정학하고 섬세함을 요구하기 때문에 어렵고 추상적이다.

`I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation.`

복잡성: 인간이 마든 그 무엇보다 복잡하다. 반복되는 것은 함수화 시키고, 커질때는 동일한 게 늘어나는 게 아니라 다른 요소가 더해진다. 수학처럼 식 하나를 뽑아냄으로써 끝나지 않고 그것들을 응용하여 다른것을 만들어 낸다. `근데 라이브러리화 해서 사용하면 되지 않나` 구조만 복잡한 게 아니라고 관리적 요소도 힘들고, 인사이동을 할때도 엄청난 러닝커브를 제공한다.

conform: 물리도 복잡하지만, 신이 만들었기 때문에 획일화된 규칙을 찾으려 한다. 하지만 소프트웨어는 인간이 맍들었기 때문에 복잡하고, 정해진 규칙에 따라야 한다. 새롭게 디자인하는 걸론 이 복잡성을 해결할 수 없다.

변경 가능성: 다른 것들에 비해 변화에 민감해 많은 변화를 요한다.

invisiblity: 간단하게 도식화 한다고 해도 이것조차 추상적이기 때문에 본질적으로 시각화 할 수 없으며 의사소통을 힘들게 한다.

과거의 문제 해결은 전부 어려움을 해결한 것이 아니라, 우연적으로 해결한 것이다.

고급 언어를 사용해 낮은 수준의 알고리즘등을 추상적으로 해결할 수 있게 하였지만, 이에대한 우리의 생각수준은 늘어나나 필요성이 감소한다. 이를 사용하기 위한 도구들에 대한 학습부담은 커져만 간다.`라이브러리도 러닝커브 있다고 말함`

시분할과정에 에러가 나면 해결하는데 많은 시간이 걸린다. 또한 일정선을 넘어가면 더이상 도움이 되지 않는다.`그래도 도움이 되지 않나`

유닉스 등 통합 프로그래밍 환경 덕에 라이브러리, 표준 포맷등이 생기며 개인적으로 프로그램을 만들때 만나는 문제점들을 해결할 수 있다. 이들로 한층 더 발전할 수 있었지만 약속과 문제점들은 존재한다.

## 우리가 기대하는 은 탄환

혁명적인가, 점진적인가 혹은 우연적인가, 본질적인가?

highlevel언어들은 복잡성을 직접 해결했다기보단 추상적으로 접근하여 처리할 수 있게 하여고, 이는 본질적인 해결이 아니다. 세부적인 어려움은 그대로고,
추상적 표현, 계층적 표현 모두 디자인을 편하게 할 수 있지만 설계단계에서의 복잡성은 그대로다.

인공지능이 혁명이 되어줄거라 기대한다.

인공지능은 결국 인간이 해야할 게 아니라 반복된 일을 해결하고, 무엇을 하려고 하는 것보다 무엇을 하려고 하는지 결정하는게 더 중요한데 AI는 그걸 해주지 못한다.

이미지인식, 음성인식 등 좋은 기능이 있다. 하지만 이를 구현하기 위해선 명확하고 분석적인 모델을 찾아 학습시키는 것, 그리고 정확하게 분류하고 만들어 내는 것이고 이는 굉장히 어렵다.

자동 프로그래밍은 결국 더 높은 수준의 프로그래밍을 지향한다. 일반화 하는 기술생산자들도 예외가 발생한다?

컴퓨터그래픽 역시 추상화되어 발전된 거지, 그것의 복잡성은 그대로다.

프로그램의 검증, 그리고 유지보수에도 많은 비용이 발생한다. 고도화된 검증을 한다고해서 오류가 없는 것도 아니고, 검증을 통해 부하를 줄인다고 해도 제거할 수는 없다. 또한 본질적으로 많은 디버깅을 요한다.

협업, 문법수정면에서는 장점이 있겠지만 MIPS(명령어 처리)는 이미 충분히 빠르고, 프로그래밍하며 생각하는 시간이 많은 걸 생각하면 더이상 도움이 되지 않을 것이다.

## 본질적 탐구

무언가 문제를 해결하는 방식의 기술적 접근보다 본질을 탐구하고 개념을 이해하는데 시간을 쏟는게 초점을 맞춰야 한다.

소프트웨어를 구성하지 않기 위한 근본적인 해결책은 직접 만들지 않는 것. 구입하는 것이 더 저렴하다.

문제는 적용 가능성이다. 기술의 발전이 빠르고, 이제 표준에 맞추는 것을 좋아한다. 표준에 맞춰 사람들에게 효율적인 프로그램을 제공한다.

소프트웨어를 만들때 가장 중요한 것은 무엇을 만들어야하는지 정확히 아는 것. 고객은 이에대해 정확히 기술하지 않는다. 완벽하다는 가정하에 하지만, 프로토타입을 만들고 돌려봐야 한다.

점진적으로 성장시켜야 한다. 디자인을 잘하는 것이 중요하다. 디자이너를 키우기 위해 노력해라.

# 정리

소프트웨어에는 은총알이 존재하지 않는다. 하드웨어의 발전이 너무나도 빠르고, 소프트웨어는 알고리즘 설계, 데이터 간의 관계, 함수의 호출 등 다양한 문제들이 결합되어 만들어지는데 이부분은 굉장히 섬세한 작업을 요하고 추상적이다. 또한 인간이 마든 그 무엇보다 복잡하다. 반복되는 것은 함수화 시키고, 커질때는 동일한 게 늘어나는 게 아니라 다른 요소가 더해진다. 수학처럼 식 하나를 뽑아냄으로써 끝나지 않고 그것들을 응용하여 다른것을 만들어 낸다. 또한 지속적으로 변하고, 도식화한다해도 본질적으로 추상적이기 때문에 볼 수 없고 의사소통이 힘들다.

고급 언어를 사용해 낮은 수준의 알고리즘등을 추상적으로 해결할 수 있게 하였지만, 이를 사용하기 위한 도구들에 대한 학습부담은 커져만 간다. highlevel언어들은 복잡성을 직접 해결했다기보단 추상적으로 접근하여 처리할 수 있게 하여고, 이는 본질적인 해결이 아니다. 세부적인 어려움은 그대로고, 추상적 표현, 계층적 표현 모두 디자인을 편하게 할 수 있지만 설계단계에서의 복잡성은 그대로다. 인공지능이 혁명이 되어줄거라 기대하지만, 인공지능은 결국 인간이 해야할 게 아니라 반복된 일을 해결하고, 무엇을 하려고 하는 것보다 무엇을 하려고 하는지 결정하는게 더 중요한데 AI는 그걸 해주지 못한다. 그리고 구현하기 위해선 명확하고 분석적인 모델을 찾아 학습시키는 것, 그리고 정확하게 분류하고 만들어 내는 것이고 이는 굉장히 어렵다. 프로그램의 검증, 그리고 유지보수에도 많은 비용이 발생한다. 고도화된 검증을 한다고해서 오류가 없는 것도 아니고, 검증을 통해 부하를 줄인다고 해도 제거할 수는 없다. 또한 본질적으로 많은 디버깅을 요한다. 협업, 문법수정면에서는 장점이 있겠지만 컴퓨터성능은 충분히 빠르고, 프로그래밍하며 생각하는 시간이 많은 걸 생각하면 더이상 도움이 되지 않을 것이다.

본질적인 어려움을 극복하기 위한 빠르고 쉬운 해결책이 없다. 무언가 문제를 해결하는 방식의 기술적 접근보다 본질을 탐구하고 개념을 이해하는데 시간을 쏟는게 초점을 맞춰야 한다. 소프트웨어를 만들때 가장 중요한 것은 무엇을 만들어야하는지 정확히 아는 것. 고객은 이에대해 정확히 기술하지 않는다. 완벽하다는 가정하에 하지만, 프로토타입을 만들고 돌려봐야 한다. 점진적으로 성장시켜야 하고 디자인을 잘하는 것이 중요하다.
